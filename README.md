# MiniJava Compiler

## Table of Contents
- [Introduction](#introduction)
- [Project Structure](#project-structure)
- [Usage](#usage)

## Introduction
The MiniJava Compiler is a lightweight toolchain, comprised distinct modules-lexer, parser, semantic analyzer, and code generator, designed to compile a subset of MiniJava code into assembly code.

### Key Features
#### Lexer: Tokenizing MiniJava Code
The lexer converts the input MiniJava source code into a stream of tokens, each representing a fundamental syntactic unit such as keywords, identifiers, literals, and operators.

#### Grammar: Parsing with LL(1) Approach
The parser processes the token stream, constructing an Abstract Syntax Tree (AST) that represents the program's structure.

#### Semantic Analyzer: Enforcing Language Rules
The semantic analyzer traverses the AST to ensure the program adheres to semantic rules such as type compatibility, scoping, and declaration usage.

#### Code Generator: Efficient Assembly Translation
The code generator translates the Abstract Syntax Tree (AST) into assembly instructions for execution, handling register allocation, control flow transition, optimized output, and runtime integration.

## Project Structure
The project is organized as follows:
```
minijava-compiler/
├── include/                        # Header files for declarations and definitions
│   ├── symbol_table.h                
│   ├── shell-ast.h  
|
├── src/ 
│   ├── codegen.c                  # Implementation for translating the AST into MIPS instructions
│   ├── grammar.y                  # YACC parser including the grammar rules for building the AST
│   ├── lex.l                      # Flex scanner for tokenizing the MiniJava code
│   ├── seman.c                    # Semantic analyzer
│   ├── string_hash_table.c        # Hash table for storage and retrieval of identifiers and string constants 
│   ├── symbol_table.c             # Symbol table for tracking identifiers and their associated attributes
│   ├── tree.c                     # Base data strcuture for building the AST
|
├── test/                          # MiniJava language code for testing the custom compiler 
| 
├── test.sh                        # Script comparing the custom compiler's output against the ground truth
├── codeGen.linux				   # A sample MiniJava compiler served as ground truth  
├── spim.linux                     # MIPS assembly simulator executes the assembly code generated by compiler
├── trap.handler                   # Handles exceptions or interrupts that occur during the execution of MIPS 
├── Makefile                       # Build script for compiling and linking the project
├── README.md                     
```

## Usage
### Building the Executables
To build the `codegen` executable, use the following command:
```bash
make
```

### Running the Compiler
Once built, you can run the compiler using the following command:
```bash
make test
```
This command will process the provided MiniJava source file and generates multiple outputs. The MIPS assembly code converted from the MiniJava source is saved in `codegen.s`. The execution output of the generated MIPS assembly code, produced by running it in the SPIM simulator, is saved in `codegen.out`. Additionally, the Abstract Syntax Tree (AST) and symbol table generated during the compilation process are saved in `ast_symbol_table.txt`.

For instance, consider a script `src1` written in MiniJava:
```
/* Ex1: Assignment statement */
program ex1;
class c1
{
	declarations
		int x=-1;
	enddeclarations
	method void main()
	declarations
		int x=4;
	enddeclarations
	{
	if (x>=0)
	  {
		System.println('x>=0'); 
	  };
	}
}
```

Run the compiler and save the outputs using the command:
```bash
./codegen < ./test/src1 > ast_symbol_table_1.txt
```

The symbol table and AST genrated from this program will be saved in `ast_symbol_table_1.txt`:
```
********************************Symbol Table************************************

          Name Nest-Level  Tree-Node Predefined        Kind       Type      Value  Offset Dimension   Argnum

  1     system          0                   yes      class                                                       
  2    println          1                   yes  procedure                                                       
  3         c1          0                            class                                                       
  4          x          1                         variable 1480276208                                            
  5       main          1                        procedure                                                       
  6          x          2                         variable 1480276560                                            
************* SYNTAX TREE PRINTOUT ***********

  +-[DUMMYnode]
R-[ProgramOp]
  |   +-[STNode,3,"c1"]
  | +-[ClassDefOp]
  | | |                 +-[DUMMYnode]
  | | |               +-[CommaOp]
  | | |               | +-[STRINGNode,29,"'x>=0'"]
  | | |             +-[RoutineCallOp]
  | | |             | |   +-[DUMMYnode]
  | | |             | | +-[SelectOp]
  | | |             | | | | +-[DUMMYnode]
  | | |             | | | +-[FieldOp]
  | | |             | | |   +-[STNode,2,"println"]
  | | |             | +-[VarOp]
  | | |             |   +-[STNode,1,"system"]
  | | |           +-[StmtOp]
  | | |           | +-[DUMMYnode]
  | | |         +-[CommaOp]
  | | |         | | +-[NUMNode,0]
  | | |         | +-[GEOp]
  | | |         |   | +-[DUMMYnode]
  | | |         |   +-[VarOp]
  | | |         |     +-[STNode,6,"x"]
  | | |       +-[IfElseOp]
  | | |       | +-[DUMMYnode]
  | | |     +-[StmtOp]
  | | |     | +-[DUMMYnode]
  | | |   +-[BodyOp]
  | | |   | |       +-[NUMNode,4]
  | | |   | |     +-[CommaOp]
  | | |   | |     | | +-[DUMMYnode]
  | | |   | |     | +-[TypeIdOp]
  | | |   | |     |   +-[INTEGERTNode]
  | | |   | |   +-[CommaOp]
  | | |   | |   | +-[STNode,6,"x"]
  | | |   | | +-[DeclOp]
  | | |   | | | +-[DUMMYnode]
  | | |   | +-[BodyOp]
  | | |   |   +-[DUMMYnode]
  | | | +-[MethodOp]
  | | | | |   +-[DUMMYnode]
  | | | | | +-[SpecOp]
  | | | | | | +-[DUMMYnode]
  | | | | +-[HeadOp]
  | | | |   +-[STNode,5,"main"]
  | | +-[BodyOp]
  | |   |         +-[DUMMYnode]
  | |   |       +-[UnaryNegOp]
  | |   |       | +-[NUMNode,1]
  | |   |     +-[CommaOp]
  | |   |     | | +-[DUMMYnode]
  | |   |     | +-[TypeIdOp]
  | |   |     |   +-[INTEGERTNode]
  | |   |   +-[CommaOp]
  | |   |   | +-[STNode,4,"x"]
  | |   | +-[DeclOp]
  | |   | | +-[DUMMYnode]
  | |   +-[BodyOp]
  | |     +-[DUMMYnode]
  +-[ClassOp]
    +-[DUMMYnode]
```

The MIPS instructions converted from this MiniJava program, saved in `code.s`:
```
.data
Enter: .asciiz "
"
.text
	j main
		# class c1
c1.init:
	addi $sp, $sp, -12
	sw $ra, 0($sp)
	sw $s1, 4($sp)
	sw $fp, 8($sp)
	move $fp, $sp
	# init x
	# c1.x
	# init scalar
	li $t1, 1
	neg $t1, $t1
	# init class var x
	sw $t1, 0($s0)
	move $sp, $fp
	lw $ra, 0($sp)
	lw $s1, 4($sp)
	lw $fp, 8($sp)
	add $sp, $sp, 12
	jr $ra
.data
.align 4
c1.singleton: .space 4
.align 4
c1.addr: .word c1.singleton
.text
c1.main:
	addi $sp, $sp, -12
	sw $ra, 0($sp)
	sw $s1, 4($sp)
	sw $fp, 8($sp)
	add $fp, $sp, $0
	# init x
	# init scalar
	li $t1, 4
	# init local var x 0
	addi $sp, $sp, -4
	sw $t1, 0($sp)
	# if
	# access local variable x
	addi $t1, $fp, -4
	lw $t1, 0($t1) #1
	addi $sp, $sp, -4
	sw $t1, 0($sp)
	li $t1, 0
	lw $t2, 0($sp)
	addi $sp, $sp, 4
	sge $t1, $t2, $t1

	beq $t1, $0, L_1
.data
S_2: .asciiz "x>=0"
.text
	li $v0, 4
	la $a0, S_2
	syscall
	j L_1
L_1:
	move $sp, $fp
	lw $ra, 0($sp)
	lw $s1, 4($sp)
	lw $fp, 8($sp)
	add $sp, $sp, 12
	jr $ra
main:
	la $s0, c1.singleton
	jal c1.init
	la $s0, c1.singleton
	jal c1.main
	li $v0, 10
	syscall
```

### Clearing the Executables
To delete the built executables and generated results, use the following command:
```bash
make clean
```