#include "symbol_table.h"
#include "tree.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
 * External function declarations
 */

/*
 * loc_str - Likely retrieves the current location in the input stream
 * or string, possibly used for error reporting or debugging.
 */
extern int loc_str();

/*
 * yyparse - Invokes the parser generated by Yacc/Bison to parse
 * the input and construct the syntax tree.
 */
extern void yyparse();

/*
 * st_top - Represents the top index or position in the symbol table stack,
 * used for managing scopes or symbol lookups.
 */
extern int st_top;

/*
 * Global Variables
 */

/*
 * SyntaxTree - Pointer to the root of the Abstract Syntax Tree (AST)
 * generated after parsing the input program.
 */
tree SyntaxTree;

/*
 * treelst - File pointer specifying the output destination for
 * the syntax tree printing.
 */
FILE *treelst;

/*
 * table - File pointer specifying the output destination for
 * the symbol table printing.
 */
FILE *table;

/*
 * Function Declarations
 */

/*
 * MkST - Builds or manipulates the syntax tree (AST) for the parsed program.
 *        Typically used during semantic analysis to augment the tree with semantic information.
 *        Implemented in seman.c.
 */
void MkST(tree);

/*
 * typeidop - Handles type identifier operations in the syntax tree.
 *            Implemented in seman.c.
 */
void typeidop(tree);

/*
 * varop - Handles variable operations in the syntax tree.
 *         Implemented in seman.c.
 */
void varop(tree, int);

/*
 * External Variables
 */

/*
 * opnodenames - Array of operation names corresponding to different node operation types in the syntax tree..
 *               Implemented in tree.c.
 */
extern char *opnodenames[];

/*
 * Function Declarations for Syntax Tree Traversal
 */

/*
 * visitVarOp - Visits and processes a variable operation node in the syntax tree.
 */
void visitVarOp(tree treenode);

/*
 * visitCall - Generates MIPS assembly code for function or method calls.
 */
void visitCall(tree treenode);

/*
 * visitStmt - Processes and generates code for a statement node in the syntax tree.
 */
void visitStmt(tree treenode);

/*
 * Operation Node Names Mapping
 */

/*
 * opnames - Maps internal node kinds to human-readable string names.
 *           This array is used for debugging, logging, or pretty-printing the syntax tree.
 */
char *opnames[] = {
    [IDNode] = "IDNode",             /* Identifier node (e.g., variable or function name) */
    [STNode] = "STNode",             /* Symbol Table node (linked to symbol table entries) */
    [INTEGERTNode] = "INTEGERTNode", /* Integer type declaration node */
    [NUMNode] = "NUMNode",           /* Numeric constant node */
    [CHARNode] = "CHARNode",         /* Character constant node */
    [STRINGNode] = "STRINGNode",     /* String constant node */
    [EXPRNode] = "EXPRNode",         /* Expression node (binary/unary operations) */
    [DUMMYNode] = "DummyNode"        /* Placeholder node (e.g., for empty branches in the tree) */
};

/*
 * Global Variables
 */

/*
 * entry - A character array that holds the entry point name (e.g., the `main` function or class).
 *         Used during code generation or for output purposes.
 */
char entry[2048];

/*
 * initwords - A buffer to store initialization code or commands in string form.
 *             This is often used during code generation to accumulate initialization steps for later output.
 */
char initwords[10240];

/*
 * visit - Function to traverse and process the syntax tree.
 */
void visit(tree treenode);

/*
 * current_offset - Tracks the current memory offset for variable allocation within a class or method.
 *                  Used to assign memory addresses for fields and local variables.
 */
int current_offset = 0;

/*
 * current_class - Stores the identifier of the class currently being processed.
 */
int current_class = 0;

/*
 * current_label - Counter for generating unique labels for control flow (e.g., loops, conditionals).
 *                 Used when emitting jump or branch instructions in code generation.
 */
int current_label = 0;

/*
 * current_method - Stores the identifier of the method currently being processed.
 *                  Similar to current_class, this references a symbol table entry for the method.
 */
int current_method = 0;

/**
 * first_method - Flag to indicate whether the first method in a class is being processed.
 *
 * Initialized to `0` and set to `1` when the first method of a class is encountered.
 * This flag helps ensure that class initialization code (e.g., memory allocation for class instances)
 * is generated only once. It prevents redundant setup code during multiple method definitions within the same class.
 */
int first_method = 0;

/**
 * first_statement - Flag to indicate whether the first statement in a method is being processed.
 *
 * Initialized to `0` and set to `1` when the first executable statement of a method is encountered.
 * This flag is used to handle method-level setups, such as stack frame allocation or symbol table updates,
 * ensuring that such setups occur only once per method.
 */
int first_statement = 0;

/**
 * myprinttree - Recursively prints the syntax tree in a structured format for debugging or visualization.
 *
 * @param treenode Pointer to the current node in the syntax tree.
 * @param indent  Current indentation level for pretty-printing.
 */
void myprinttree(tree treenode, int indent) {
    int intv = 0; // Holds the integer value of the node, if applicable.

    // If the node is not an expression node, extract its integer value.
    if (NodeKind(treenode) != EXPRNode) {
        intv = IntVal(treenode);
    }

    // Print indentation using "+-" pattern for readability.
    for (int i = 0; i < indent / 2; ++i) {
        printf("%c ", "+-"[i % 2]);
    }

    // Determine the operation or node type for the current tree node.
    int q = NodeKind(treenode);

    // Align with the 0-based 'opnodenames' index
    q = NodeOp(treenode) - ProgramOp;

    // Check if the current node is null.
    if (IsNull(treenode)) {
        printf("(null)\n"); // Print "(null)" for null nodes.
    } else {
        // Print the node's kind, operation name, and integer value.
        printf("[%s,%s,%d]", opnames[NodeKind(treenode)], opnodenames[q], intv);

        // If the node is a symbol table node, print the associated name.
        if (NodeKind(treenode) == STNode) {
            printf("%s", getname(GetAttr(intv, NAME_ATTR)));
        }
        printf("\n");
    }

    // Recursively print the left and right children of the current node.
    if (!IsNull(treenode)) {
        myprinttree(LeftChild(treenode), indent + 2); // Increase indentation for child nodes.
        myprinttree(RightChild(treenode), indent + 2);
    }
}

/*
 * Macros for Code Simplification
 */

/*
 * DefGetNameAt(a) - Retrieves the name of a symbol (e.g., variable, method, or class)
 *                   from the symbol table using the integer value from a tree node.
 *                   `a` is a tree node, and the macro extracts its NAME_ATTR attribute.
 *
 * Example usage:
 * DefGetNameAt(treenode) -> char *name = getname(GetAttr(IntVal(treenode), NAME_ATTR));
 */
#define DefGetNameAt(a) char *name = getname(GetAttr(IntVal(a), NAME_ATTR));

/*
 * ActionPrintTree - Calls `myprinttree` to print the entire syntax tree starting from `treenode`.
 *                   Useful for debugging the tree structure.
 */
#define ActionPrintTree myprinttree(treenode, 0);

/*
 * ActionVisitLeft - Recursively visits the left child of the current tree node.
 *                   Used for general-purpose tree traversal.
 */
#define ActionVisitLeft visit(LeftChild(treenode));

/*
 * ActionVisitRight - Recursively visits the right child of the current tree node.
 *                    Complements `ActionVisitLeft` for full binary tree traversal.
 */
#define ActionVisitRight visit(RightChild(treenode));

/*
 * ActionVisitExprLeft - Specifically visits the left child of an expression node.
 *                       Used during expression evaluation or code generation.
 */
#define ActionVisitExprLeft visitExpr(LeftChild(treenode));

/*
 * ActionVisitExprRight - Specifically visits the right child of an expression node.
 *                        Complements `ActionVisitExprLeft` for handling binary expressions.
 */
#define ActionVisitExprRight visitExpr(RightChild(treenode));

/*
 * ActionVisitStmtLeft - Visits the left child of a statement node.
 *                       Useful for processing compound statements or control structures.
 */
#define ActionVisitStmtLeft visitStmt(LeftChild(treenode));

/*
 * ActionVisitStmtRight - Visits the right child of a statement node.
 *                        Complements `ActionVisitStmtLeft` for handling statement sequences.
 */
#define ActionVisitStmtRight visitStmt(RightChild(treenode));

/**
 * Struct: proto
 * -------------
 * Represents a node in a linked list for storing function/method prototypes or variable sizes.
 *
 * Members:
 * - next: Pointer to the next `proto` node in the linked list.
 * - id:   Identifier (name) of the function/method or variable.
 * - arg:  Argument type string for functions/methods (NULL for variables).
 * - v:    Integer value, used for different purposes:
 *         - For functions: may be used as a flag or version number.
 *         - For variables: stores the size of the variable.
 */
struct proto {
    struct proto *next; // Pointer to the next prototype in the list.
    char *id;           // Identifier (function/method name or variable name).
    char *arg;          // Argument signature (used for functions, NULL for variables).
    int v;              // Value (0 for functions, size for variables).
} *proto_list = NULL;   // Head of the linked list for prototypes.

/**
 * addProto - adds a new function/method prototype to the `proto_list`.
 *
 * @param id The name of the function/method.
 * @param arg The argument signature (e.g., "VIV" for "void, int, void").
 */
void addProto(char *id, char *arg) {
    struct proto *p = malloc(sizeof(struct proto)); // Allocate memory for the new node.
    p->id = id;                                     // Set the function/method name.
    p->arg = arg;                                   // Set the argument type signature.
    p->v = 0;                                       // Initialize value to 0 (used for functions).

    // Insert the new node at the beginning of the linked list.
    p->next = proto_list;
    proto_list = p;
}

/**
 * addSize - adds a new variable or class size entry to the `proto_list`.
 *
 * @param id The name of the variable or class.
 * @param v The size (in bytes) of the variable or class.
 */
void addSize(char *id, int v) {
    struct proto *p = malloc(sizeof(struct proto)); // Allocate memory for the new node.
    p->id = id;                                     // Set the variable or class name.
    p->v = v;                                       // Set the size value.

    // Insert the new node at the beginning of the linked list.
    p->next = proto_list;
    proto_list = p;
}

/**
 * findProto - searches for a function/method prototype in the `proto_list` by its identifier (`id`).
 *
 * @param id The name of the function/method to search for.
 */
char *findProto(char *id) {
    // Traverse the linked list of prototypes
    for (struct proto *p = proto_list; p; p = p->next) {
        // Compare the provided id with the current node's id (case-sensitive)
        if (!strcmp(p->id, id)) {
            return p->arg; // Return the argument signature if a match is found
        }
    }
    return NULL; // Return NULL if the prototype is not found
}

/**
 * findSize - searches for a variable/class size in the `proto_list` by its identifier (`id`).
 *
 * @param id The name of the variable or class to search for.
 */
int findSize(char *id) {
    // Traverse the linked list of prototypes
    for (struct proto *p = proto_list; p; p = p->next) {
        // Compare the provided id with the current node's id (case-insensitive)
        if (!strcasecmp(p->id, id)) {
            return p->v; // Return the size if a match is found
        }
    }
    return 0; // Return 0 if the size is not found
}

/**
 * opGenTable - Lookup table for generating MIPS assembly instructions for basic operations.
 *
 * This table maps operation types (e.g., addition, subtraction, logical comparisons) to their
 * corresponding MIPS assembly code snippets. It simplifies the code generation process by providing
 * quick access to pre-defined instruction patterns for each operation.
 *
 * The generated instructions use `$t1` and `$t2` registers for intermediate computations.
 */
char *opGenTable[] = {
    /* Arithmetic Operations */

    [AddOp] = "\tadd $t1, $t2, $t1\n",  // Addition: $t1 = $t2 + $t1
    [SubOp] = "\tsub $t1, $t2, $t1\n",  // Subtraction: $t1 = $t2 - $t1
    [MultOp] = "\tmul $t1, $t1, $t2\n", // Multiplication: $t1 = $t1 * $t2
    [DivOp] = "\tdiv $t1, $t1, $t2\n",  // Division: $t1 = $t1 / $t2

    /* Relational Comparison Operations */

    [LTOp] = "\tslt $t1, $t2, $t1\n", // Less than: $t1 = ($t2 < $t1)
    [GTOp] = "\tsgt $t1, $t2, $t1\n", // Greater than: $t1 = ($t2 > $t1)
    [EQOp] = "\tseq $t1, $t2, $t1\n", // Equal to: $t1 = ($t2 == $t1)
    [NEOp] = "\tsne $t1, $t2, $t1\n", // Not equal to: $t1 = ($t2 != $t1)
    [LEOp] = "\tsle $t1, $t2, $t1\n", // Less than or equal to: $t1 = ($t2 <= $t1)
    [GEOp] = "\tsge $t1, $t2, $t1\n", // Greater than or equal to: $t1 = ($t2 >= $t1)

    /* Logical Operations */

    [AndOp] = "\tsne $t1, $t1, $0\n" // Logical AND:
              "\tsne $t2, $t2, $0\n" // Convert both operands to boolean (0 or 1)
              "\tand $t1, $t2, $t1", // $t1 = $t2 && $t1

    [OrOp] = "\tsne $t1, $t1, $0\n" // Logical OR:
             "\tsne $t2, $t2, $0\n" // Convert both operands to boolean (0 or 1)
             "\tor $t1, $t2, $t1",  // $t1 = $t2 || $t1
};

/**
 * visitExpr - Generates MIPS assembly code for evaluating expressions in the syntax tree.
 *
 * @param treenode The syntax tree node representing the expression.
 *
 * This function recursively traverses the expression tree and emits the appropriate
 * MIPS assembly instructions to evaluate the expression. It handles numeric constants,
 * variables, unary/binary operations, and function calls.
 */
void visitExpr(tree treenode) {

    // Handle null expressions by setting the result to 0
    if (IsNull(treenode)) {
        printf("\tadd $t1, $0, $0\n"); // $t1 = 0
        return;
    }

    // Process the expression node based on its kind
    switch (NodeKind(treenode)) {

    // Handle numeric constants (e.g., literals like 42)
    case NUMNode: {
        int intval = IntVal(treenode); // Get the numeric value of the node

        // If the value fits in a 12-bit immediate, load it directly
        if (-2048 < intval && intval <= 2048) {
            printf("\tli $t1, %d\n", intval); // Load immediate: $t1 = intval, for 12-bit values
        } else {
            // For larger numbers, store them in the data section and load them
            int label = ++current_label;
            printf(".data\n");
            printf("\tC_%d: .word %d\n", label, intval); // Define constant in data section
            printf(".text\n");
            printf("la $t1, C_%d\n", label); // Load address of constant
            printf("lw $t1, 0($t1)\n");      // Load the constant into $t1
        }
        return;
    }

    // Handle expression nodes (binary/unary operations, function calls, etc.)
    case EXPRNode: {
        switch (NodeOp(treenode)) {

        // Handle unary negation (e.g., -x)
        case UnaryNegOp: {
            ActionVisitExprLeft             // Evaluate the left child
                printf("\tneg $t1, $t1\n"); // Negate the result
            return;
        }

        // Handle logical NOT (e.g., !x)
        case NotOp: {
            ActionVisitExprLeft                // Evaluate the left child
                printf("\tseq $t1, $t1, 0\n"); // Set $t1 to 1 if $t1 == 0, else 0
            return;
        }

        // Handle variable access (e.g., x)
        case VarOp: {
            visitVarOp(treenode);            // Load the address of the variable
            printf("\tlw $t1, 0($t1) #1\n"); // Load the variable's value into $t1
            return;
        }

        // Handle binary arithmetic and logical operations
        case AddOp:  // Addition (+)
        case SubOp:  // Subtraction (-)
        case MultOp: // Multiplication (*)
        case DivOp:  // Division (/)
        case LTOp:   // Less than (<)
        case GTOp:   // Greater than (>)
        case EQOp:   // Equal (==)
        case NEOp:   // Not equal (!=)
        case GEOp:   // Greater than or equal (>=)
        case LEOp:   // Less than or equal (<=)
        case AndOp:  // Logical AND (&&)
        case OrOp: { // Logical OR (||)

            ActionVisitExprLeft                  // Evaluate the left operand
                printf("\taddi $sp, $sp, -4\n"); // Make space for the value on the stack by decreasing 4 bytes
            printf("\tsw $t1, 0($sp)\n");        // Store the value from $t1 onto the stack

            ActionVisitExprRight              // Evaluate the right operand
                printf("\tlw $t2, 0($sp)\n"); // Load the left operand back into $t2
            printf("\taddi $sp, $sp, 4\n");   // Restore the stack pointer

            // Emit the corresponding operation code from the lookup table
            puts(opGenTable[NodeOp(treenode)]);
            break;
        }

        // Handle function or method calls
        case RoutineCallOp: {
            visitCall(treenode);         // Generate code for the function call
            printf("\tmove $t1, $v0\n"); // Move the return value into $t1
            return;
        }
        }
    }
    }
}

/**
 * visitArrayComma - Generates MIPS code to allocate and initialize an array.
 *
 * @param treenode The syntax tree representing a comma-separated array initializer.
 *
 * This function handles array initialization with multiple values, like:
 *     int arr[] = {1, 2, 3};
 *
 * The function does the following:
 * 1. Calculates the number of elements.
 * 2. Allocates memory on the heap.
 * 3. Iterates through the initializer and stores each value in the array.
 */
void visitArrayComma(tree treenode) {
    // Calculate the number of elements to initialize (depth - 1 due to tree structure)
    int n = LeftDepth(treenode) - 1;

    /*** Memory Allocation for the Array ***/

    // Allocate memory for the array: size = number of elements * 4 (word size)
    printf("\tli $a0, %d\n", LeftDepth(treenode) * 4); // Load size into $a0
    printf("\tli $v0, 9\n");                           // System call code for sbrk (memory allocation)
    printf("\tsyscall\n");                             // Request memory allocation
    printf("\tmove $t1, $v0\n");                       // Store the base address of the allocated memory in $t1

    // Push the base address of the array onto the stack for temporary storage
    printf("\taddi $sp, $sp, -4\n"); // Adjust stack pointer to make space
    printf("\tsw $t1, 0($sp)\n");    // Store array base address on the stack

    /*** Array Initialization Loop ***/

    // Loop to evaluate and store each initializer expression into the allocated array
    while (n >= 0) {
        visitExpr(RightChild(treenode)); // Evaluate the current initializer expression

        printf("\tlw $t2, 0($sp)\n");         // Load the base address of the array into $t2
        printf("\tsw $t1, %d($t2)\n", n * 4); // Store the evaluated value into the correct array index

        treenode = LeftChild(treenode); // Move to the next initializer (left child)
        n--;                            // Decrement the index for the next array element
    }

    /*** Restore Stack Pointer ***/

    // Restore the stack pointer by popping the array base address
    printf("\tlw $t1, 0($sp)\n");   // Reload the base address into $t1
    printf("\taddi $sp, $sp, 4\n"); // Restore the stack pointer
}

/**
 * visitLoadInit - Generates MIPS code for initializing variables and arrays.
 *
 * @param treenode The syntax tree node representing a variable or array initialization.
 *
 * This function handles different types of variable initializations:
 * 1. **Array Initialization** - Dynamically allocates memory for arrays and initializes elements.
 * 2. **Scalar Initialization** - Initializes scalar variables (integers, expressions).
 * 3. **Default Initialization** - Sets variables to zero if no initializer is provided.
 */
void visitLoadInit(tree treenode) {
    int type = NodeOp(RightChild(treenode));   // Operation type of the initializer
    int kind = NodeKind(RightChild(treenode)); // Node kind of the initializer (e.g., NUMNode, EXPRNode)

    /*** Case 1: Array Initialization ***/
    if (type == ArrayTypeOp) {
        tree obj = LeftChild(RightChild(treenode)); // Extract the array initializer object

        // Check how the array is initialized: by size (`BoundOp`) or by values (`CommaOp`)
        switch (NodeOp(obj)) {

        /*** Case 1.1: Array Initialized with a Size (BoundOp) ***/
        case BoundOp: {
            // Evaluate the size expression (e.g., int arr[10]; → evaluate 10)
            visitExpr(RightChild(obj));

            // Multiply the size by 4 to allocate space for 32-bit words
            printf("\tsll $t1, $t1, 2\n"); // $t1 = $t1 << 2 → $t1 = size * 4

            // Pass the size to the memory allocation syscall
            printf("\tmove $a0, $t1\n"); // Move size into $a0 for syscall
            printf("\tli $v0, 9\n");     // Syscall 9: sbrk (allocate memory)
            printf("\tsyscall\n");       // Allocate memory
            printf("\tmove $t1, $v0\n"); // Store the base address of the allocated array in $t1
            break;
        }

        /*** Case 1.2: Array Initialized with Explicit Values (CommaOp) ***/
        case CommaOp: {
            // Handle array initialization with multiple values (e.g., int arr[] = {1, 2, 3};)
            visitArrayComma(obj);
            break;
        }
        }

        /*** Case 2: Scalar Initialization (e.g., int x = 5; or int x = a + b;) ***/
    } else if (kind == NUMNode || kind == EXPRNode) {
        printf("\t# init scalar\n");
        visitExpr(RightChild(treenode)); // Evaluate and load the scalar initializer into $t1

        /*** Case 3: Default Initialization (Uninitialized Variables) ***/
    } else {
        printf("\t# init zero\n");
        printf("\tli $t1, 0\n"); // Default initialization to 0 if no explicit initializer
    }
}

/**
 * visitClassStore - Generates MIPS code to initialize and store a **class field**.
 *
 * @param treenode The syntax tree node representing the **class field** declaration.
 *
 * This function is responsible for initializing and storing **class fields** (member variables).
 * It performs the following steps:
 *
 * 1. **Allocates memory** for the field if it is an object of another class.
 * 2. **Calls the field's class `.init` method** to properly initialize the object.
 * 3. **Stores the initialized object's address** into the correct memory offset of the class.
 * 4. **Updates the symbol table** to mark the member as a **FIELD** with its memory offset.
 *
 * ---
 * **Example Usage:**
 *
 * Given the class definition:
 *
 * ```java
 * class Person {
 *     int age;
 *     Address addr;
 * }
 * ```
 *
 * When creating a `Person` object, the `visitClassStore` function will initialize the `addr` field.
 *
 * **Generated MIPS Assembly for `addr` Initialization:**
 *
 * ```assembly
 * # Allocate memory for 'addr' (Address object)
 * li $a0, 8            # Assume Address object requires 8 bytes
 * li $v0, 9            # Syscall 9: sbrk (memory allocation)
 * syscall
 * move $s1, $s0        # Save the current object context
 * move $s0, $v0        # $s0 now points to the new Address object
 *
 * # Call Address.init to initialize 'addr'
 * jal Address.init
 *
 * # Store the initialized 'addr' in the Person object
 * move $t1, $s0        # Move the initialized Address object's address to $t1
 * move $s0, $s1        # Restore the original object context
 * sw $t1, 4($s0)       # Store 'addr' at offset 4 of the Person object
 * ```
 *
 * **Explanation:**
 * - **Memory Allocation:** Allocates 8 bytes for the `Address` object using the `sbrk` system call.
 * - **Initialization:** Calls `Address.init` to initialize the `addr` object.
 * - **Storage:** Stores the initialized object's address at the correct offset in the `Person` object.
 */
void visitClassStore(tree treenode) {
    // Retrieve the name of the class field being initialized
    DefGetNameAt(treenode);
    printf("\t# init class var %s\n", name);

    /*** Step 1: Retrieve the Field's Type Information ***/

    // Get the symbol table index for this field
    int id = IntVal(treenode);

    // Retrieve the type of the field (could be a primitive type or another class)
    tree t = LeftChild(GetAttr(id, TYPE_ATTR));

    /*** Step 2: If the Field is an Object (Class Type), Allocate and Initialize It ***/

    if (NodeKind(t) == STNode) {
        /**
         * Allocate memory for the field if it is an object of another class.
         * - `findSize` determines how many bytes to allocate for the object.
         * - Uses the `sbrk` syscall (syscall 9) to allocate memory dynamically.
         */

        // Load the size of the field's class type into $a0 (argument for syscall)
        printf("\tli $a0, %d\n", findSize(getname(GetAttr(IntVal(t), NAME_ATTR))));

        // Load syscall number 9 (`sbrk`) into $v0 for dynamic memory allocation
        printf("\tli $v0, 9\n");

        // Perform the syscall to allocate memory
        printf("\tsyscall\n");

        /**
         * Save the current object context in `$s1` and set `$s0` to the newly allocated object.
         *
         * - `$s0` typically holds the **current object context** during class initialization.
         * - `$s1` is used as temporary storage to **preserve the outer object's context**.
         */
        printf("\tmove $s1, $s0\n"); // Save current object context
        printf("\tmove $s0, $v0\n"); // `$s0` now points to the allocated field object

        /**
         * Call the `.init` method of the field's class to initialize its attributes.
         * - Ensures the newly allocated object is properly set up.
         */
        printf("\tjal %s.init\n", getname(GetAttr(IntVal(t), NAME_ATTR)));

        /**
         * After initialization, store the object's address in `$t1` and restore `$s0`.
         * - `$t1` will be used to store the object into the current class.
         * - `$s0` is restored to continue initializing other fields in the class.
         */
        printf("\tmove $t1, $s0\n"); // Save initialized object's address into `$t1`
        printf("\tmove $s0, $s1\n"); // Restore outer object context
    }

    /*** Step 3: Store the Initialized Field in the Class Object ***/

    /**
     * Store the initialized field object into the class's memory layout.
     * - **`current_offset`** holds the memory offset where this field should be stored.
     * - `$s0` holds the **base address** of the class object being initialized.
     */
    printf("\tsw $t1, %d($s0)\n", current_offset); // Store field address at proper offset

    /*** Step 4: Update the Symbol Table to Reflect the Field's State ***/

    /**
     * Update the symbol table to:
     * - Record the field's **memory offset**.
     * - Mark the symbol as a **FIELD** to differentiate it from local/global variables.
     */
    SetAttr(IntVal(treenode), OFFSET_ATTR, current_offset); // Save offset in symbol table
    SetAttr(IntVal(treenode), KIND_ATTR, FIELD);            // Mark as a FIELD in the class
}

/**
 * visitLocalStore - Generates MIPS code to initialize and store a **local variable**.
 *
 * @param treenode The syntax tree node representing the local variable declaration.
 *
 * This function handles the initialization of **local variables** in a function or method.
 * It performs the following steps:
 *
 * 1. **Allocates memory** for the local variable if it is an object of a class type.
 * 2. **Calls the object's `.init` method** for proper initialization if needed.
 * 3. **Updates the symbol table** to store the variable's memory offset and mark it as a **local variable (VAR)**.
 * 4. **Stores the variable's address** onto the stack.
 */
void visitLocalStore(tree treenode) {
    // Retrieve the name of the local variable being initialized
    DefGetNameAt(treenode);
    printf("\t# init local var %s %d\n", name, current_offset);

    /*** Step 1: Retrieve the Local Variable's Type Information ***/

    // Get the symbol table index for this local variable
    int id = IntVal(treenode);

    // Get the type of the variable (could be a primitive type or a class)
    tree t = LeftChild(GetAttr(id, TYPE_ATTR));

    /*** Step 2: If the Local Variable is an Object (Class Type), Allocate and Initialize It ***/

    if (NodeKind(t) == STNode) {
        /**
         * Allocate memory for the local variable if it is an object of a class.
         * - `findSize` determines how many bytes to allocate for the object's type.
         * - Uses the `sbrk` syscall (syscall 9) to allocate memory dynamically.
         */

        // Print the type of the object being initialized
        printf("\t# : %s\n", getname(GetAttr(IntVal(t), NAME_ATTR)));

        // Load the size of the object's type into $a0 (argument for syscall)
        printf("\tli $a0, %d\n", findSize(getname(GetAttr(IntVal(t), NAME_ATTR))));

        // Load syscall number 9 (`sbrk`) into $v0 for dynamic memory allocation
        printf("\tli $v0, 9\n");

        // Perform the syscall to allocate memory
        printf("\tsyscall\n");

        /**
         * Save the current context in `$s1` and assign the allocated memory address to `$s0`.
         *
         * - `$s0` holds the base address of the current object being initialized.
         * - `$s1` temporarily holds the outer context to restore after initialization.
         */
        printf("\tmove $s1, $s0\n"); // Save the current object context
        printf("\tmove $s0, $v0\n"); // `$s0` now points to the newly allocated object

        /**
         * Call the object's `.init` method to initialize its attributes.
         * - Ensures the object is properly set up after memory allocation.
         */
        printf("\tjal %s.init\n", getname(GetAttr(IntVal(t), NAME_ATTR)));

        /**
         * After initialization, save the object's address into `$t1` and restore `$s0`.
         * - `$t1` will be used to store the object on the stack.
         */
        printf("\tmove $t1, $s0\n"); // Save initialized object's address into `$t1`
        printf("\tmove $s0, $s1\n"); // Restore the previous object context
    }

    /*** Step 3: Update the Symbol Table for the Local Variable ***/

    /**
     * Update the symbol table to:
     * - Record the variable's **memory offset** in the current stack frame.
     * - Mark the symbol as a **local variable (VAR)**.
     */
    SetAttr(IntVal(treenode), OFFSET_ATTR, current_offset); // Set memory offset
    SetAttr(IntVal(treenode), KIND_ATTR, VAR);              // Mark as a local variable

    /*** Step 4: Store the Initialized Object or Primitive Variable on the Stack ***/

    /**
     * Reserve space on the stack and store the address of the initialized variable.
     * - **`addi $sp, $sp, -4`** decreases the stack pointer to make space.
     * - **`sw $t1, 0($sp)`** stores the variable's address or value on the stack.
     */
    printf("\taddi $sp, $sp, -4\n"); // Allocate space on the stack
    printf("\tsw $t1, 0($sp)\n");    // Store the object's address or value
}

/**
 * visitClassDefOp - Generates MIPS code for a class definition and its initialization.
 *
 * @param treenode The syntax tree node representing the class definition.
 *
 * This function performs the following tasks for defining a class:
 * 1. Generates the class's `.init` method to initialize its fields.
 * 2. Sets up the stack frame for the initialization routine.
 * 3. Allocates memory for a singleton instance of the class.
 * 4. Records the class size for memory allocation.
 * 5. Appends initialization code to ensure the class is properly set up at runtime.
 */
void visitClassDefOp(tree treenode) {
    /*** Step 1: Retrieve the Class Name ***/

    // Extract the class name from the right child of the class definition node
    DefGetNameAt(RightChild(treenode));
    printf("\t# class %s\n", name); // Comment for debugging: which class is being initialized

    /*** Step 2: Define the Class Initialization Routine ***/

    // Start the class's `.init` method, which initializes class fields
    printf("%s.init:\n", name);

    /**
     * Step 2.1: Set up the stack frame for the `.init` method.
     * - Save the return address (`$ra`) to return after initialization.
     * - Save `$s1` (object context) and `$fp` (frame pointer) for restoration later.
     */
    printf("\taddi $sp, $sp, -12\n"); // Allocate space for `$ra`, `$s1`, and `$fp`
    printf("\tsw $ra, 0($sp)\n");     // Save return address
    printf("\tsw $s1, 4($sp)\n");     // Save `$s1` (object context)
    printf("\tsw $fp, 8($sp)\n");     // Save frame pointer
    printf("\tmove $fp, $sp\n");      // Set up the frame pointer

    /*** Step 3: Initialize Class Fields ***/

    // Prepare to initialize class fields by resetting relevant tracking variables
    first_method = 1;                             // Flag to track if any method was defined
    current_class = IntVal(RightChild(treenode)); // Record the current class's symbol table index
    current_offset = 0;                           // Reset field offset for the class

    // Visit the left and right children to initialize fields and methods
    ActionVisitLeft      // Initialize class fields
        ActionVisitRight // Initialize class methods

        /*** Step 4: Finalize Initialization if No Methods Exist ***/

        if (first_method) {
        /**
         * If no methods were defined, finalize the `.init` routine.
         * - Restore the stack frame and return.
         */
        printf("\tmove $sp, $fp\n");    // Restore stack pointer
        printf("\tlw $ra, 0($sp)\n");   // Restore return address
        printf("\tlw $s1, 4($sp)\n");   // Restore `$s1`
        printf("\tlw $fp, 8($sp)\n");   // Restore frame pointer
        printf("\tadd $sp, $sp, 12\n"); // Deallocate stack frame
        printf("\tjr $ra\n");           // Return from `.init`

        /*** Step 5: Allocate Memory for the Singleton Instance of the Class ***/

        /**
         * Create a singleton instance of the class in the `.data` section.
         * - This allows global access to a single shared instance of the class.
         * - The `.singleton` holds the class's data, and `.addr` points to it.
         */
        printf(".data\n");
        char *name = getname(GetAttr(current_class, NAME_ATTR));             // Retrieve the class name again
        printf(".align 4\n%s.singleton: .space %d\n", name, current_offset); // Reserve space for fields
        printf(".align 4\n%s.addr: .word %s.singleton\n", name, name);       // Pointer to the singleton

        // Record the size of the class for future memory allocation
        addSize(getname(GetAttr(current_class, NAME_ATTR)), current_offset);

        // Switch back to the `.text` section for executable code
        printf(".text\n");

        // Reset the method flag after setup
        first_method = 0;
    }

    /**
     * Step 6: Append Initialization Code for Singleton Setup
     * ------------------------------------------------------
     * This block of code generates the necessary MIPS assembly instructions to
     * initialize the **singleton instance** of a class. The generated code is
     * collected and stored in the global buffer `initwords` for deferred execution.
     *
     * **Why This Is Needed:**
     * - **Deferred Initialization:** Singleton objects must be initialized **before**
     *   the program's `main` function runs. Collecting the initialization code ensures
     *   all singleton objects are properly set up at program startup.
     * - **Centralized Initialization:** If there are multiple classes, this approach
     *   consolidates all singleton initializations in one place, ensuring a consistent
     *   and ordered setup.
     * - **Avoids Redundant Initialization:** This prevents initializing objects multiple
     *   times or out of order, which could happen if immediate `printf` statements were used.
     *
     * **How It Works:**
     * 1. **Code Generation:**
     *    - `sprintf` formats the assembly code to load the singleton object into `$s0`
     *      and call its `.init` method.
     *    - Example for class `Person`:
     *      ```
     *      la $s0, Person.singleton   # Load the singleton object's address
     *      jal Person.init            # Call the class's initializer
     *      ```
     *
     * 2. **Code Collection:**
     *    - `strcat` appends the generated code to the `initwords` buffer, allowing
     *      all singleton initializations to be collected together.
     *
     * 3. **Execution at Startup:**
     *    - The collected code in `initwords` is injected into the program's startup
     *      sequence in `codegenFinish()`:
     *      ```c
     *      printf("main:\n%s\tla $s0, %s.singleton\n\tjal %s.main\n\tli $v0, 10\n\tsyscall\n",
     *             initwords, entry, entry);
     *      ```
     *    - This ensures that all singleton objects are **fully initialized** before
     *      the program's logic begins.
     *
     * **Example Workflow:**
     * - For classes `Person` and `Address`, the following initialization code is generated:
     *   ```
     *   la $s0, Person.singleton
     *   jal Person.init
     *   la $s0, Address.singleton
     *   jal Address.init
     *   ```
     * - This ensures both objects are **allocated** and **initialized** before any
     *   function calls (like `main`) occur.
     *
     * **Why Not Just Use `printf` Directly?**
     * - Using `printf` would immediately output the code, potentially scattering
     *   initializations across the program and risking incorrect order.
     * - Collecting in `initwords` ensures a **centralized** and **ordered** setup
     *   of all necessary singleton objects.
     */

    char s[1024];
    sprintf(s, "\tla $s0, %s.singleton\n\tjal %s.init\n", name, name);
    strcat(initwords, s); // Add the initialization sequence to the global setup
}

/**
 * visitHead - Processes the method/function header to set up parameters and metadata.
 *
 * @param treenode The syntax tree node representing the method's parameters (SpecOp).
 * @param head The syntax tree node representing the method's head (HeadOp), which includes the method name.
 *
 * **Purpose:**
 * This function sets up the **argument list** and updates the **symbol table** with parameter details
 * for a method or function. It tracks the order and type of parameters (by reference or by value)
 * and records the method's prototype for future calls.
 *
 * **Key Steps:**
 * 1. **Process Parameters:**
 *    - Traverses the parameter list to determine whether each parameter is a **reference** or **value** argument.
 *    - Updates the **symbol table** with this information and assigns each parameter an **offset** for memory access.
 *
 * 2. **Build Prototype Signature:**
 *    - Constructs a compact signature (`arg`) representing the parameter types (`'R'` for reference, `'V'` for value).
 *    - Example: For a method with signature `foo(int a, ref int b)`, the argument string would be `"VR"`.
 *
 * 3. **Register the Method Prototype:**
 *    - Combines the class name and method name to form a fully qualified method name (e.g., `"ClassName.MethodName"`).
 *    - Stores the method prototype using `addProto()` for later use during method calls.
 */

void visitHead(tree treenode, tree head) {
    /*** Step 1: Initialize Parameter Processing ***/

    tree spec = LeftChild(treenode); // Get the parameter specification list
    current_offset = 0;              // Reset the offset counter for method arguments

    // Allocate memory for storing the argument type signature ('R' for ref, 'V' for value)
    char *arg = malloc(20); // Assume a max of 20 parameters
    char *pp = arg;         // Pointer to fill in the argument signature

    /*** Step 2: Process Each Parameter ***/

    while (!IsNull(spec)) {
        int id = IntVal(LeftChild(LeftChild(spec))); // Get the parameter's symbol table index

        switch (NodeOp(spec)) {
        /*** Handle Reference Arguments ***/
        case RArgTypeOp: {
            SetAttr(id, KIND_ATTR, REF_ARG);          // Mark as a reference argument
            SetAttr(id, OFFSET_ATTR, current_offset); // Set memory offset
            *pp = 'R';                                // Add 'R' to the argument signature
            ++pp;
            break;
        }

        /*** Handle Value Arguments ***/
        case VArgTypeOp: {
            SetAttr(id, KIND_ATTR, VALUE_ARG);        // Mark as a value argument
            SetAttr(id, OFFSET_ATTR, current_offset); // Set memory offset
            *pp = 'V';                                // Add 'V' to the argument signature
            ++pp;
            break;
        }
        }

        current_offset += 4;     // Increment offset by 4 bytes for each argument
        spec = RightChild(spec); // Move to the next parameter in the list
    }

    *pp = '\0'; // Null-terminate the argument signature string

    /*** Step 3: Register the Method Prototype ***/

    // Allocate memory for the full method name (ClassName.MethodName)
    char *name = malloc(1024);
    char *currentClass = getname(GetAttr(current_class, NAME_ATTR));         // Get current class name
    char *methodName = getname(GetAttr(IntVal(LeftChild(head)), NAME_ATTR)); // Get method name

    // Format the fully qualified method name as "ClassName.MethodName"
    sprintf(name, "%s.%s", currentClass, methodName);

    // Add the method prototype (name and argument signature) to the prototype list
    addProto(name, arg);
}

/**
 * visitInitMethod - Generates MIPS assembly code for method initialization.
 *
 * @param treenode The syntax tree node representing the method declaration.
 *
 * This function sets up the method's stack frame and prepares it for execution.
 * It performs the following steps:
 *
 * 1. **Processes the method header** using `visitHead()` to handle parameter setup.
 * 2. **Initializes the stack frame** by saving necessary registers.
 * 3. **Handles special treatment for the `main` method** to mark the program's entry point.
 * 4. **Prepares the frame pointer** for local variable access.
 */
void visitInitMethod(tree treenode) {
    /*** Step 1: Extract Method Name ***/

    // Get the method name (used for labeling the method in assembly)
    DefGetNameAt(LeftChild(LeftChild(treenode)));

    /*** Step 2: Process Method Parameters and Setup ***/

    // Process the method's parameter list and set up argument handling
    visitHead(RightChild(LeftChild(treenode)), LeftChild(treenode));

    // Record the method's symbol table index for later reference
    current_method = IntVal(LeftChild(LeftChild(treenode)));

    // Reset the offset for local variables
    current_offset = 0;

    // Mark that the first statement of the method hasn't been processed yet
    first_statement = 1;

    /*** Step 3: Define the Method Label ***/

    // Print the method's label in the format: ClassName.MethodName:
    printf("%s.%s:\n",
           getname(GetAttr(current_class, NAME_ATTR)), // Class name
           name);                                      // Method name

    /*** Step 4: Handle the `main` Method Entry Point ***/

    // If this is the `main` method, mark it as the program entry point
    if (!strcmp(name, "main")) {
        // Store the class name that contains `main` into `entry` for later use
        strcpy(entry, getname(GetAttr(current_class, NAME_ATTR)));
    }

    /*** Step 5: Stack Frame Setup ***/

    /**
     * Allocate 12 bytes on the stack to save:
     * - `$ra`: Return address (for function returns)
     * - `$s1`: Saved register (for preserving important values)
     * - `$fp`: Frame pointer (for local variable access)
     */
    printf("\taddi $sp, $sp, -12\n"); // Make space on the stack

    // Save the return address to the stack
    printf("\tsw $ra, 0($sp)\n");

    // Save the `$s1` register to the stack (used to preserve outer object context)
    printf("\tsw $s1, 4($sp)\n");

    // Save the current frame pointer to the stack
    printf("\tsw $fp, 8($sp)\n");

    /*** Step 6: Initialize the Frame Pointer ***/

    // Set the frame pointer (`$fp`) to the current stack pointer (`$sp`)
    printf("\tadd $fp, $sp, $0\n");
}

/**
 * visitExitMethod - Generates MIPS code to clean up the stack and return from a method.
 *
 * @param treenode The syntax tree node representing the method (unused in this function).
 *
 * This function restores the stack and register state before exiting a method. It ensures that:
 * 1. The stack pointer (`$sp`) is reset to its state before the method call.
 * 2. Saved registers (`$ra`, `$s1`, `$fp`) are restored to their original values.
 * 3. Control is returned to the calling function via the return address (`$ra`).
 */
void visitExitMethod(tree treenode) {
    /*** Step 1: Restore the Stack Pointer ***/
    // Reset `$sp` to point to the method's stack frame (saved in `$fp`)
    printf("\tmove $sp, $fp\n");

    /*** Step 2: Restore Saved Registers ***/
    // Restore the return address (`$ra`) to return to the caller
    printf("\tlw $ra, 0($sp)\n");

    // Restore the `$s1` register (previous object context or saved data)
    printf("\tlw $s1, 4($sp)\n");

    // Restore the previous frame pointer (`$fp`)
    printf("\tlw $fp, 8($sp)\n");

    /*** Step 3: Deallocate the Stack Frame ***/
    // Reclaim the 12 bytes of stack space used to save `$ra`, `$s1`, and `$fp`
    printf("\tadd $sp, $sp, 12\n");

    /*** Step 4: Return to the Caller ***/
    // Jump back to the return address saved in `$ra`
    printf("\tjr $ra\n");
}

/**
 * visitMethodOp - Generates MIPS assembly code for method definitions.
 *
 * @param treenode The syntax tree node representing a method (`MethodOp`).
 *
 * This function handles the setup, execution, and cleanup for methods within a class.
 * It performs the following steps:
 *
 * 1. **First Method Initialization:**
 *    - Finalizes the class initialization if this is the first method encountered.
 *    - Sets up the singleton instance and restores the stack if needed.
 *
 * 2. **Method Initialization:**
 *    - Initializes the method stack frame and prepares for execution.
 *
 * 3. **Method Body Generation:**
 *    - Recursively generates the method's body code.
 *
 * 4. **Method Cleanup:**
 *    - Restores the stack and registers after method execution.
 */
void visitMethodOp(tree treenode) {
    /*** Step 1: Finalize Class Initialization if First Method ***/
    if (first_method) {
        /**
         * If this is the first method being processed:
         * - Restore the previous stack frame (if any).
         * - Finalize the singleton instance setup for the class.
         */

        // Restore the previous stack frame
        printf("\tmove $sp, $fp\n");    // Reset stack pointer to frame pointer
        printf("\tlw $ra, 0($sp)\n");   // Restore return address
        printf("\tlw $s1, 4($sp)\n");   // Restore `$s1` register
        printf("\tlw $fp, 8($sp)\n");   // Restore frame pointer
        printf("\tadd $sp, $sp, 12\n"); // Deallocate the saved stack frame
        printf("\tjr $ra\n");           // Return from the initialization routine

        /*** Step 2: Create Singleton Instance for the Class ***/
        printf(".data\n");

        // Retrieve the current class name for memory allocation
        char *name = getname(GetAttr(current_class, NAME_ATTR));

        // Allocate space for the singleton instance of the class
        printf(".align 4\n%s.singleton: .space %d\n", name, current_offset);

        // Define a pointer to the singleton instance
        printf(".align 4\n%s.addr: .word %s.singleton\n", name, name);

        // Record the size of the class for future allocations
        addSize(getname(GetAttr(current_class, NAME_ATTR)), current_offset);

        // Switch back to the `.text` section for executable code
        printf(".text\n");

        // Mark that the first method has been handled
        first_method = 0;
    }

    /*** Step 3: Initialize the Method ***/
    // Set up the method's stack frame and prepare for execution
    visitInitMethod(treenode);

    /*** Step 4: Generate the Method Body ***/
    // Generate code for the method's body (statements and expressions)
    ActionVisitRight;

    /*** Step 5: Finalize the Method ***/
    // Restore the stack and registers after the method finishes
    visitExitMethod(treenode);
}

/**
 * visitClassInit - Initializes a **class-level** variable or field.
 *
 * @param treenode The syntax tree node representing the class variable initialization.
 *
 * This function handles the initialization of **class fields** (member variables). It:
 * 1. Retrieves the class name for context.
 * 2. Allocates and initializes memory for the class field.
 * 3. Stores the initialized value in the class's memory structure.
 */
void visitClassInit(tree treenode) {
    DefGetNameAt(LeftChild(treenode)); // Get the field's name (e.g., `addr` in `Person.addr`)

    // Retrieve the current class name for debugging/comment purposes
    char *classname = getname(GetAttr(current_class, NAME_ATTR));
    printf("\t# %s.%s\n", classname, name); // Comment for the assembly output

    // Initialize the field (allocate memory or set default value)
    visitLoadInit(RightChild(treenode));

    // Store the initialized field in the appropriate offset of the class
    visitClassStore(LeftChild(treenode));
}

/**
 * visitLocalInit - Initializes a **local** variable.
 *
 * @param treenode The syntax tree node representing the local variable initialization.
 *
 * This function handles the initialization of **local variables** within methods. It:
 * 1. Allocates memory or sets default values for the local variable.
 * 2. Stores the initialized value on the **stack**.
 */
void visitLocalInit(tree treenode) {
    visitLoadInit(RightChild(treenode));  // Allocate or initialize the variable
    visitLocalStore(LeftChild(treenode)); // Store the initialized value on the stack
}

/**
 * visitInit - General initializer for variables (class fields or local variables).
 *
 * @param treenode The syntax tree node representing the variable initialization.
 *
 * This function determines **whether a variable is a class field or a local variable**
 * based on its **nesting level** and calls the appropriate initializer.
 *
 * - **Class Field (Level 1):** Calls `visitClassInit` for member variables.
 * - **Local Variable (Level > 1):** Calls `visitLocalInit` for method-local variables.
 */
void visitInit(tree treenode) {
    DefGetNameAt(LeftChild(treenode)); // Get the variable/field name
    printf("\t# init %s\n", name);     // Comment indicating the initialization step

    // Determine the variable's scope by its nesting level:
    // - Level 1 → Class field (global to the class)
    // - Level > 1 → Local variable (inside a method)
    int level = GetAttr(IntVal(LeftChild(treenode)), NEST_ATTR);
    if (level == 1) {
        visitClassInit(treenode); // Initialize class field
    } else {
        visitLocalInit(treenode); // Initialize local variable
    }

    current_offset += 4; // Reserve space for the next variable
}

/**
 * visitDeclOp - Processes a declaration operation (`DeclOp`) in the abstract syntax tree (AST).
 *
 * This function handles the declaration of variables, fields, or other constructs
 * represented by a `DeclOp` node in the AST. It ensures that both the left and right
 * children of the node are processed.
 *
 * Workflow:
 * 1. **Visit the Left Child**: The left child of a `DeclOp` typically contains previous
 *    declarations or is `NullExp()` if this is the first declaration. This step ensures
 *    any chained declarations are processed recursively.
 *
 * 2. **Initialize the Right Child**: The right child of a `DeclOp` represents the current
 *    declaration being processed (e.g., a variable name, type, and initializer). The
 *    `visitInit()` function is called to handle this initialization.
 *
 * Example AST:
 *
 * For the code:
 * ```c
 * int x, y = 5;
 * ```
 * The AST would look like:
 * ```
 * DeclOp
 * ├── DeclOp
 * │   ├── NullExp()  // No previous declarations
 * │   └── CommaOp
 * │       ├── IDNode ("x")  // Variable name
 * │       └── CommaOp
 * │           ├── TypeIdOp → INTEGERTNode ("int")  // Variable type
 * │           └── NullExp()  // No initializer
 * └── CommaOp
 *     ├── IDNode ("y")  // Variable name
 *     └── CommaOp
 *         ├── TypeIdOp → INTEGERTNode ("int")  // Variable type
 *         └── ICONSTNode (5)  // Initializer for `y`
 * ```
 *
 * Code Generation Workflow:
 * - `ActionVisitLeft`: Recursively processes the left child to handle any prior declarations.
 * - `visitInit`: Handles initialization for the current declaration (e.g., setting variable
 *   offsets, generating initialization code).
 *
 * @param treenode The syntax tree node representing the `DeclOp`.
 */
void visitDeclOp(tree treenode) {
    ActionVisitLeft                      // Process the left child (previous declarations).
        visitInit(RightChild(treenode)); // Initialize the current declaration.
}

/**
 * visitSpecOp - Placeholder function for processing `SpecOp` nodes.
 *
 * **Context:**
 * `SpecOp` nodes typically represent specific language constructs, such as type
 * specifications in method declarations or parameter lists. However, the actual
 * logic for handling these constructs is already managed during tree building
 * (e.g., in the grammar rules for `FormalParameterList_z1` in `grammar.y`).
 *
 * **Purpose:**
 * This function is currently a no-op because the necessary processing is already
 * covered during syntax tree construction.
 *
 * **Related Functions:**
 * - `visitHead` handles the integration of parameter lists and return types
 *   during method initialization.
 * - `visitMethodOp` indirectly leverages these nodes when processing methods.
 *
 * @param treenode The syntax tree node representing the `SpecOp`.
 */
void visitSpecOp(tree treenode) {
    // No additional processing needed here as `SpecOp` nodes are resolved earlier.
}

/**
 * visitTypeIdOp - Placeholder function for processing `TypeIdOp` nodes.
 *
 * **Context:**
 * `TypeIdOp` nodes represent type declarations (e.g., `int`, `void`, or user-defined types).
 * During the tree-building phase, these nodes are created and integrated into the
 * tree structure as part of variable or parameter declarations.
 *
 * **Purpose:**
 * This function is currently a no-op because type resolution and integration are
 * handled during syntax tree construction (e.g., in `FieldDecl` or `MethodDecl`).
 *
 * **Related Functions:**
 * - `visitInit` and `visitDeclOp` process the usage of type information when
 *   initializing variables or fields.
 * - `getTypeName` extracts and uses type information for further processing.
 *
 * @param treenode The syntax tree node representing the `TypeIdOp`.
 */
void visitTypeIdOp(tree treenode) {
    // No additional processing needed here as `TypeIdOp` nodes are resolved earlier.
}

/**
 * getTypeName - Retrieves the type name of a variable or object from the syntax tree.
 *
 * @param y The syntax tree node representing a variable, object, or array.
 *
 * @return A string representing the type of the given node:
 *         - `"int"` for scalar integers.
 *         - `"int[]"` for integer arrays.
 *         - The **class name** for user-defined types (objects).
 *
 * This function analyzes the `TYPE_ATTR` of the given node and determines whether
 * it is a primitive type (like `int`), an array, or a user-defined class type.
 *
 * **Example Usage:**
 *
 * ```c
 * int x;         // getTypeName(x) → "int"
 * int arr[5];    // getTypeName(arr) → "int[]"
 * Person p;      // getTypeName(p) → "Person"
 * ```
 */
char *getTypeName(tree y) {
    // Step 1: Retrieve the type node from the symbol table
    tree p = LeftChild(GetAttr(y, TYPE_ATTR)); // Get the type information

    // Step 2: Check if the type is a primitive or array type
    if (NodeKind(p) != STNode) { // If not a user-defined type (class/struct)

        // Case 1: Primitive integer type
        if (NodeKind(p) == INTEGERTNode) {
            return "int"; // Return "int" for scalar integers
        }
        // Case 2: Array of integers or unknown type
        else {
            return "int[]"; // Default to "int[]" for arrays or unsupported types
        }
    }

    // Step 3: Handle user-defined types (class/struct)
    // If the type is a user-defined structure (STNode), return its name
    return getname(GetAttr(IntVal(p), NAME_ATTR));
}

/**
 * visitVarSingle - Generates MIPS assembly code to access a variable or object.
 *
 * @param treenode The syntax tree node representing the variable access.
 *
 * @return A string representing the type of the accessed variable.
 *
 * This function generates the appropriate assembly code to load the address or value
 * of a variable into register `$t1` based on its kind (local variable, class field,
 * argument, or object). It also determines and returns the type of the variable.
 *
 * **Variable Types Handled:**
 *   - **Local Variable (VAR):** Accessed through the frame pointer (`$fp`).
 *   - **Class Field (FIELD):** Accessed through the object base pointer (`$s0`).
 *   - **Class Instance (CLASS):** Accessed via a global singleton pointer.
 *   - **Value Argument (VALUE_ARG):** Passed by value on the stack.
 *   - **Reference Argument (REF_ARG):** Passed by reference (pointer).
 *
 * **Example Code Generation:**
 * ```c
 * int x;               // Local variable → `addi $t1, $fp, -offset-4`
 * this.age;            // Class field    → `addi $t1, $s0, offset`
 * Person p;            // Class object   → `la $t1, Person.addr`
 * void func(int y);    // Value arg      → `add $t1, $fp, offset+12`
 * void func(int* y);   // Ref arg        → `lw $t1, offset+12($fp)`
 * ```
 */
char *visitVarSingle(tree treenode) {
    // Retrieve the variable's name from the symbol table
    DefGetNameAt(LeftChild(treenode)); // `name` now holds the variable's name

    int y = IntVal(LeftChild(treenode)); // Get the symbol table index for the variable

    char *type; // Will hold the variable's type (e.g., "int", "Person")

    // Determine how to access the variable based on its kind (VAR, FIELD, etc.)
    switch (GetAttr(y, KIND_ATTR)) {

    /*** Case 1: Local Variable (VAR) ***/
    case VAR: {
        printf("\t# access local variable %s\n", name);

        int offset = GetAttr(y, OFFSET_ATTR); // Offset in the stack

        type = getTypeName(y); // Get the variable's type

        /**
         * Stack Layout for Local Variables:
         * ---------------------------------
         * Local variables are stored below the saved region of the stack frame:
         *   - Frame Pointer (`$fp`) points to:
         *       0($fp): Return Address (`$ra`)
         *       4($fp): Saved Register (`$s1`)
         *       8($fp): Saved Frame Pointer (`$fp`)
         *   - Local variables begin at lower offsets, accessed using `$fp - offset - 4`.
         */
        printf("\taddi $t1, $fp, %d\n", -offset - 4); // Compute variable address
        break;
    }

    /*** Case 2: Class Field (FIELD) ***/
    case FIELD: {
        printf("\t# access class field %s\n", name);

        int offset = GetAttr(y, OFFSET_ATTR); // Offset in the object's memory
        type = getTypeName(y);                // Get the field's type

        /**
         * Object Layout for Class Fields:
         * --------------------------------
         * Fields are stored at fixed offsets relative to the object's base:
         *   - Base Address (`$s0`): Points to the object
         *   - `offset`: Byte offset of the field
         * Fields are accessed as `$s0 + offset`.
         */
        printf("\taddi $t1, $s0, %d\n", offset); // Compute field address
        break;
    }

    /*** Case 3: Class Instance (CLASS) ***/
    case CLASS: {
        /**
         * Singleton Class Access:
         * -----------------------
         * Each class has a singleton instance allocated in the `.data` section:
         *   - `<class>.addr`: Points to the singleton instance
         *   - `la`: Loads the singleton's address into `$t1`
         */
        printf("\tla $t1, %s.addr\n", name); // Load singleton address
        type = name;                         // The class name serves as its type
        break;
    }

    /*** Case 4: Value Argument (VALUE_ARG) ***/
    case VALUE_ARG: {
        int offset = GetAttr(y, OFFSET_ATTR); // Offset for the argument
        type = getTypeName(y);                // Get the argument's type

        /**
         * Stack Layout for Value Arguments:
         * ---------------------------------
         * Value arguments are stored above the saved registers in the stack frame:
         *   - Frame Pointer (`$fp`) points to:
         *       0($fp): Return Address (`$ra`)
         *       4($fp): Saved Register (`$s1`)
         *       8($fp): Saved Frame Pointer (`$fp`)
         *   - Arguments begin at `$fp + 12` and are accessed as `$fp + offset + 12`.
         */
        printf("\tadd $t1, $fp, %d\n", offset + 12); // Compute argument address
        break;
    }

    /*** Case 5: Reference Argument (REF_ARG) ***/
    case REF_ARG: {
        int offset = GetAttr(y, OFFSET_ATTR); // Offset for the argument
        type = getTypeName(y);                // Get the argument's type

        /**
         * Stack Layout for Reference Arguments:
         * -------------------------------------
         * Reference arguments are passed as pointers on the stack:
         *   - Stored above the saved registers, starting at `$fp + 12`
         *   - The pointer is loaded from the stack using `lw`.
         */
        printf("\tlw $t1, %d($fp)\n", offset + 12); // Load argument pointer
        break;
    }
    }

    return type; // Return the variable's type for further processing
}

/**
 * visitVarOp - Generates MIPS assembly code to access variables, fields, and array elements.
 *
 * @param treenode The syntax tree node representing the variable or field access.
 *
 * This function resolves complex variable access patterns, including:
 *   - Simple variables
 *   - Object fields (`.` operator)
 *   - Array indexing (`[]`)
 *
 * It generates the appropriate MIPS instructions to compute the correct memory address
 * or value for the given access pattern.
 */
void visitVarOp(tree treenode) {
    /*** Step 1: Handle Simple Variable Access ***/
    // Calls `visitVarSingle` to handle simple variables, fields, or arguments
    // This loads the base address of the variable/object into `$t1`
    visitVarSingle(treenode);

    /*** Step 2: Handle Chained Field Access or Array Indexing ***/
    // Traverse through chained accesses (e.g., `obj.field1.field2` or `array[i][j]`)
    while (!IsNull(RightChild(treenode))) {

        // Check if the next operation is a field access (`.`) or array index (`[]`)
        if (NodeOp(RightChild(treenode)) == SelectOp) {

            /*** Case 1: Object Field Access (`.` operator) ***/
            if (NodeOp(LeftChild(RightChild(treenode))) == FieldOp) {
                // Retrieve the symbol table index of the accessed field
                int id = IntVal(LeftChild(LeftChild(RightChild(treenode))));

                // Get the field's type and its memory offset within the object
                int ofs = GetAttr(id, OFFSET_ATTR);

                // Load the base address of the object instance stored at `$t1`
                printf("\tlw $t1, 0($t1)\n");

                // Add the field's offset to `$t1` to access the correct field
                printf("\taddi $t1, $t1, %d\n", ofs);
            }

            /*** Case 2: Array Indexing (`[]` operator) ***/
            else if (NodeOp(LeftChild(RightChild(treenode))) == IndexOp) {
                // Load the base address of the array into `$t1`
                printf("\tlw $t1, 0($t1)\n");

                // Push the base address of the array onto the stack for later use
                printf("\taddi $sp, $sp, -4\n");
                printf("\tsw $t1, 0($sp)\n");

                // Evaluate the index expression (e.g., `arr[i]` → compute `i`)
                visitExpr(LeftChild(LeftChild(RightChild(treenode))));

                // Multiply the index by 4 (`sll` shifts left by 2 bits) to convert to a byte offset
                printf("\tsll $t1, $t1, 2\n");

                // Pop the array's base address back into `$t2`
                printf("\tlw $t2, 0($sp)\n");
                printf("\taddi $sp, $sp, 4\n");

                // Add the computed offset to the base address → `$t1 = base + index * 4`
                printf("\tadd $t1, $t2, $t1\n");
            }
        }

        // Move to the next right child for further chained access
        treenode = RightChild(treenode);
    }
}

/**
 * visitVarOpWithCall - Resolves variable or object accesses followed by a method call or further operations.
 *
 * @param treenode The syntax tree node representing the variable or object access.
 * @param proto A pointer to store the retrieved method prototype (output parameter).
 * @param funcname A pointer to store the fully qualified method name (output parameter).
 *
 * This function is used in scenarios where variable or object accesses are followed by:
 * - **Method calls:** Resolves the method's prototype and fully qualified name for code generation.
 * - **Chained accesses:** Handles cases like `obj.field.method()` or `obj.arrayField[i].method()`.
 * - **Array indexing:** Computes offsets for array access within an object context.
 *
 * Use Cases:
 * 1. **Object Method Calls**:
 *    Handles scenarios like:
 *    ```c
 *    obj.method();
 *    ```
 *    - Resolves `obj`.
 *    - Retrieves `method`'s prototype and fully qualified name.
 *
 * 2. **Chained Method Calls or Accesses**:
 *    Handles scenarios like:
 *    ```c
 *    obj.field.method();
 *    ```
 *    - Resolves `obj`.
 *    - Accesses `field` and updates the base address.
 *    - Retrieves and resolves `method`.
 *
 * 3. **Accessing Array Elements in Object Context**:
 *    Handles scenarios like:
 *    ```c
 *    obj.arrayField[i].method();
 *    ```
 *    - Computes the base address of `arrayField`.
 *    - Calculates the offset for index `i`.
 *    - Resolves the element's method call.
 *
 * 4. **Argument Resolution in Function Calls**:
 *    Handles scenarios like:
 *    ```c
 *    foo(obj.method());
 *    ```
 *    - Resolves `obj.method()` as part of the arguments for `foo`.
 *
 * 5. **Prototyping and Dynamic Information Retrieval**:
 *    - Retrieves the prototype of a method (`proto`) and its fully qualified name (`funcname`)
 *      for code generation and validation.
 */
void visitVarOpWithCall(tree treenode, char **proto, char **funcname) {
    // Step 1: Resolve the base variable or object reference
    char *name = visitVarSingle(treenode); // Process the base variable or object

    // Step 2: Traverse through chained field or array accesses
    while (!IsNull(RightChild(treenode))) {

        // Check if the next operation is a field or method access (SelectOp)
        if (NodeOp(RightChild(treenode)) == SelectOp) {

            // Check if the accessed entity is a field (FieldOp)
            if (NodeOp(LeftChild(RightChild(treenode))) == FieldOp) {
                int id = IntVal(LeftChild(LeftChild(RightChild(treenode)))); // Get field's ID
                tree type = GetAttr(id, KIND_ATTR);                          // Get the kind of the accessed entity

                if (type == FIELD) {                                          // If it is a class field
                    int k = GetAttr(id, TYPE_ATTR);                           // Get the field's type
                    name = getname(GetAttr(IntVal(LeftChild(k)), NAME_ATTR)); // Update the name for chained access
                    int ofs = GetAttr(id, OFFSET_ATTR);                       // Get the field's offset

                    // Load the field's value
                    printf("\tlw $t1, 0($t1)\n");                       // Dereference the current object pointer
                    printf("\taddi $t1, $t1, %d\n", ofs);               // Add the offset to access the field
                } else {                                                // If it is a method
                    char *fname = getname(GetAttr(id, NAME_ATTR));      // Get the method name
                    char *s = malloc(strlen(name) + strlen(fname) + 2); // Allocate space for the fully qualified name
                    sprintf(s, "%s.%s", name, fname);                   // Format the fully qualified name (e.g., Class.method)
                    *funcname = s;                                      // Set the function name
                    *proto = findProto(s);                              // Retrieve the method's prototype
                }
            }
            // Check if the accessed entity is an array element (IndexOp)
            else if (NodeOp(LeftChild(RightChild(treenode))) == IndexOp) {
                // Load the base address of the array
                printf("\tlw $t1, 0($t1)\n");

                // Push the base address onto the stack for later use
                printf("\taddi $sp, $sp, -4\n");
                printf("\tsw $t1, 0($sp)\n");

                // Evaluate the index expression (e.g., `arr[i]`)
                visitExpr(LeftChild(LeftChild(RightChild(treenode))));

                // Convert the index to a byte offset (multiply by 4)
                printf("\tsll $t1, $t1, 2\n");

                // Pop the base address of the array from the stack
                printf("\tlw $t2, 0($sp)\n");
                printf("\taddi $sp, $sp, 4\n");

                // Add the computed offset to the base address
                printf("\tadd $t1, $t2, $t1\n");
            }
        }
        // Move to the next node in the access chain
        treenode = RightChild(treenode);
    }
}

/**
 * visitRoutineCallOp - Placeholder for handling routine (function or method) calls.
 *
 * @param treenode The syntax tree node representing a routine call (`RoutineCallOp`).
 *
 * This function is intended to handle the semantic analysis and code generation
 * for routine calls. However, it is left unimplemented in this codebase because:
 *
 * 1. **Routine Calls Are Already Handled Elsewhere**:
 *    - The `visitStmt` function includes a case for `RoutineCallOp`, which delegates
 *      to the `visitCall` function for generating the required assembly code.
 *    - `visitCall` handles everything related to routine calls, such as argument setup,
 *      calling the appropriate function, and handling return values.
 *
 * 2. **Code Duplication Avoidance**:
 *    - Implementing `visitRoutineCallOp` would duplicate the functionality already
 *      provided by `visitCall` and `visitStmt`.
 *
 * 3. **Simplified Traversal**:
 *    - The `visit` function iterates through the syntax tree and delegates node-specific
 *      tasks to specialized functions (e.g., `visitCall` for routine calls). As such,
 *      there is no need for `visitRoutineCallOp` to duplicate this effort.
 *
 * Example:
 * ```
 * foo(10, 20);  // Routine call
 * ```
 *
 * In the code:
 * - `visitStmt` identifies this as a `RoutineCallOp`.
 * - It calls `visitCall` to generate MIPS assembly for the call, including:
 *   - Argument evaluation and pushing onto the stack.
 *   - Emitting the `jal` instruction to jump to the routine.
 *   - Handling the return value (if any) in `$v0`.
 */
void visitRoutineCallOp(tree treenode) {}

/**
 * visitIfStmt - Generates MIPS assembly code for an `if` statement.
 *
 * @param treenode The syntax tree node representing the `if` statement.
 * @param false_label The label to jump to if the condition evaluates to false.
 * @param end_label The label to jump to at the end of the `if` statement block.
 *
 * This function recursively handles nested `if` statements and generates
 * appropriate assembly code to evaluate conditions and control program flow.
 *
 * Workflow:
 * 1. Recursively handle nested conditions in the left subtree of the syntax tree.
 * 2. Evaluate the condition expression and branch based on its result.
 * 3. Generate labels and jump instructions to implement conditional execution.
 *
 * Examples:
 *
 * Example 1: Simple `if` with a condition
 * ---------------------------------------
 * Source Code:
 * if (x > 0) { print(x); }
 *
 * Syntax Tree (Simplified):
 * IfElseOp
 * ├── NullExp()
 * └── CommaOp
 *     ├── (x > 0) - condition
 *     └── print(x) - statement
 *
 * Assembly Output:
 *   # if
 *   <evaluate (x > 0) into $t1>
 *   beq $t1, $0, L_false  # Branch to L_false if (x > 0) is false
 *   <generate code for print(x)>
 *   j L_end               # Jump to L_end after execution
 * L_false:
 * L_end:
 *
 * Example 2: Nested `if`
 * -----------------------
 * Source Code:
 * if (x > 0) {
 *     if (y < 5) { print(y); }
 * }
 *
 * Syntax Tree (Simplified):
 * IfElseOp
 * ├── IfElseOp (nested condition)
 * │   ├── NullExp()
 * │   └── CommaOp
 * │       ├── (y < 5) - condition
 * │       └── print(y) - statement
 * └── CommaOp
 *     ├── (x > 0) - condition
 *     └── NullExp()
 *
 * Assembly Output:
 *   # if
 *   <evaluate (x > 0) into $t1>
 *   beq $t1, $0, L_false
 *   L_nested:
 *     <evaluate (y < 5) into $t1>
 *     beq $t1, $0, L_nested_false
 *     <generate code for print(y)>
 *     j L_end
 *   L_nested_false:
 *   L_false:
 *   L_end:
 */
void visitIfStmt(tree treenode, int false_label, int end_label) {
    printf("\t# if\n"); // Add a comment in the assembly code for clarity

    // Step 1: Handle nested conditions on the left child
    if (!IsNull(LeftChild(treenode))) {
        int here = ++current_label;                        // Generate a new label for the current condition
        visitIfStmt(LeftChild(treenode), here, end_label); // Recursively process the left child
        printf("\tL_%d:\n", here);                         // Emit the label for the current condition
    }

    // Step 2: Process the right child (the main `if` condition and its body)
    tree rhs = RightChild(treenode);

    // Case 1: The right child is a `CommaOp` node (condition, statement)
    if (NodeOp(rhs) == CommaOp) {
        visitExpr(LeftChild(rhs));                    // Evaluate the condition and leave the result in `$t1`
        printf("\tbeq $t1, $0, L_%d\n", false_label); // Branch to `false_label` if the condition is false
        visitStmt(RightChild(rhs));                   // Generate code for the `if` body (executed when the condition is true)
        printf("\tj L_%d\n", end_label);              // Jump to the end of the `if` block after execution
    }
    // Case 2: The right child is not a `CommaOp` (e.g., simple `if` without a condition)
    else {
        visitStmt(rhs);                  // Generate code for the `if` body
        printf("\tj L_%d\n", end_label); // Jump to the end of the `if` block
    }
}

/**
 * Checks if the given tree node represents a call to the `system` object.
 *
 * This function determines if the provided syntax tree node corresponds to
 * a reference to the `system` object, typically used for system-level
 * functions such as `println`, `readln`, etc.
 *
 * @param treenode The root node of the syntax tree to analyze.
 * @return `true` if the node represents a reference to the `system` object;
 *         `false` otherwise.
 *
 * Example Usage:
 *
 * Source Code:
 *     system.println("Hello, World!");
 *
 * Corresponding Syntax Tree:
 *     RoutineCallOp
 *     ├── VarOp (system)
 *     │   ├── STNode ("system")
 *     │   └── NullExp() (No further access)
 *     └── CommaOp (Arguments to println)
 *         ├── STRINGNode ("Hello, World!")
 *         └── NullExp() (No further arguments)
 *
 * Function Call:
 *     isSystem(treenode);
 *
 * Execution:
 *     1. `treenode` points to the `RoutineCallOp` node.
 *     2. The left child (`lhs`) of `treenode` is the `VarOp` for `system`.
 *     3. The left child of `VarOp` is an `STNode` with the name "system".
 *     4. `isSystem` identifies the name as "system" and returns `true`.
 */
int isSystem(tree treenode) {
    // Extract the left child of the current node.
    // This is assumed to be the variable or object being referenced.
    tree lhs = LeftChild(treenode);

    // Step 1: Check if the left child is a variable operation (VarOp).
    // VarOp nodes typically represent variables, fields, or object references.
    if (NodeOp(lhs) == VarOp) {
        // Step 2: Extract the left child of the variable operation (VarOp).
        // This would typically be the name or identifier of the object/variable.
        tree lhslhs = LeftChild(lhs);

        // Step 3: Check if the node represents a symbol table reference (STNode).
        // STNode indicates that the identifier is resolved in the symbol table.
        if (NodeKind(lhslhs) == STNode) {
            // Step 4: Retrieve the name of the identifier from the symbol table.
            DefGetNameAt(lhslhs);

            // Step 5: Compare the identifier's name with "system".
            // If the name matches "system", return true.
            if (!strcmp(name, "system")) {
                return true; // The node refers to the `system` object.
            }
        }
    }

    // If any of the above conditions are not met, return false.
    return false;
}

/**
 * visitLoadString - Generates MIPS assembly code to load a string constant into memory.
 *
 * This function allocates a new label in the `.data` section for the given string,
 * stores it as a null-terminated ASCII string, and returns the label index for later use.
 *
 * @param str The input string to be loaded into memory.
 * @return An integer representing the unique label index assigned to the string.
 *
 * Workflow:
 * 1. Switch to the `.data` section for defining string constants.
 * 2. Allocate a new label for the string using an incremented global label counter.
 * 3. Create a copy of the input string, removing the enclosing quotes.
 * 4. Emit the string as an `.asciiz` directive in the assembly code.
 * 5. Free the allocated memory for the modified string.
 * 6. Return the label index for referencing the string in the `.text` section.
 *
 * Example Usage:
 *
 * Source Code:
 *     print("Hello, World!");
 *
 * Generated MIPS Assembly:
 *     .data
 *     S_1: .asciiz "Hello, World!"
 *     .text
 *     li $v0, 4       # System call to print string
 *     la $a0, S_1     # Load address of string S_1
 *     syscall
 */
int visitLoadString(char *str) {
    printf(".data\n"); // Switch to the `.data` section for string constants

    int p = ++current_label; // Generate a unique label index for the string

    // Allocate memory for the input string and create a copy
    char *s = malloc(strlen(str) + 1);
    strcpy(s, str);

    // Remove the enclosing quotes from the string
    s[strlen(s) - 1] = '\0';

    // Emit the string as a null-terminated ASCII string in the `.data` section
    printf("S_%d: .asciiz \"%s\"\n", p, s + 1);

    free(s); // Free the memory allocated for the modified string

    printf(".text\n"); // Switch back to the `.text` section for executable code

    return p; // Return the label index for referencing the string
}

/**
 * cbPrint - Generates MIPS assembly code to print a value or string.
 *
 * This function handles printing of both string constants and evaluated expressions.
 * It generates the appropriate system calls (`syscall`) to print either a string
 * or an integer based on the type of the input node.
 *
 * @param treenode The syntax tree node representing the value to be printed.
 *
 * Workflow:
 * 1. Check the kind of the input node (`NodeKind`) to determine its type.
 * 2. If the node represents a string constant:
 *    - Call `visitLoadString` to load the string into memory and get its label.
 *    - Generate assembly code to print the string using MIPS system call `4`.
 *    - Set the `strNode` flag to indicate a string has been processed.
 * 3. For other types (e.g., integer expressions):
 *    - Evaluate the expression using `visitExpr` (result stored in `$t1`).
 *    - Generate assembly code to print the integer using MIPS system call `1`.
 * 4. Emit the appropriate `syscall` instruction to invoke the printing operation.
 *
 * Example Usage:
 *
 * Source Code:
 *     println("Hello, World!");
 *     println(x + 42);
 *
 * Generated MIPS Assembly:
 *     .data
 *     S_1: .asciiz "Hello, World!"
 *     .text
 *     li $v0, 4       # System call to print string
 *     la $a0, S_1     # Load address of string S_1
 *     syscall         # Print string
 *
 *     li $t1, 42      # Evaluate x + 42 (assuming x = 0 for simplicity)
 *     li $v0, 1       # System call to print integer
 *     add $a0, $t1, $0 # Load result into $a0
 *     syscall         # Print integer
 */
int strNode = 0;

void cbPrint(tree treenode) {
    // Determine the type of the node using its kind
    switch (NodeKind(treenode)) {

    /*** Case 1: String Node ***/
    case STRINGNode: {
        // Load the string into memory and get its label
        int c = visitLoadString(getstring(IntVal(treenode)));

        // Set up the MIPS system call for printing strings
        printf("\tli $v0, 4\n");       // System call code for print string
        printf("\tla $a0, S_%d\n", c); // Load the address of the string label into $a0
        printf("\tsyscall\n");         // Perform the system call to print the string

        strNode = 1; // Indicate that a string node was processed
        return;      // Exit after handling the string
    }

    /*** Default Case: Other Types (e.g., Integer Expressions) ***/
    default:
        visitExpr(treenode); // Evaluate the expression (result stored in $t1)

        // Set up the MIPS system call for printing integers
        printf("\tli $v0, 1\n");        // System call code for print integer
        printf("\tadd $a0, $t1, $0\n"); // Move the result from $t1 to $a0
        printf("\tsyscall\n");          // Perform the system call to print the integer
    }
}

/**
 * cbRead - Callback function to generate MIPS assembly code for reading input into a variable.
 *
 * This function handles the input operation for a given variable node in the syntax tree.
 * It generates the appropriate MIPS assembly instructions to:
 * 1. Resolve the memory location of the variable.
 * 2. Read an integer from standard input using the MIPS syscall for input.
 * 3. Store the read value into the resolved memory location.
 *
 * @param treenode The syntax tree node representing the variable to read input into.
 *
 * Example 1: Reading a value into a simple variable
 * -----------------------------------------------
 * Input:
 *     int x;
 *     readln(x);
 *
 * Assembly Output:
 *     addi $t1, $fp, -4       # Resolve address of x into $t1
 *     li $v0, 5               # Set up syscall for integer input
 *     syscall                 # Perform input operation
 *     sw $v0, 0($t1)          # Store input value into x
 *
 * Example 2: Reading a value into an array element
 * -----------------------------------------------
 * Input:
 *     int arr[10];
 *     readln(arr[3]);
 *
 * Assembly Output:
 *     lw $t1, 0($t1)          # Resolve base address of arr into $t1
 *     addi $sp, $sp, -4       # Push base address onto stack
 *     sw $t1, 0($sp)
 *     li $t1, 3               # Evaluate index (3)
 *     sll $t1, $t1, 2         # Convert index to byte offset
 *     lw $t2, 0($sp)          # Pop base address from stack into $t2
 *     add $t1, $t2, $t1       # Compute effective address of arr[3]
 *     li $v0, 5               # Set up syscall for integer input
 *     syscall                 # Perform input operation
 *     sw $v0, 0($t1)          # Store input value into arr[3]
 */
void cbRead(tree treenode) {
    // Step 1: Resolve the memory location of the variable
    // This generates the code to load the variable's address into `$t1`.
    visitVarOp(treenode);

    // Step 2: Set up the syscall for reading an integer
    // `$v0 = 5` specifies the syscall number for reading an integer in MIPS.
    printf("\tli $v0, 5\n");

    // Step 3: Execute the syscall
    // This performs the read operation and stores the result in `$v0`.
    printf("\tsyscall\n");

    // Step 4: Store the read value into the variable's memory location
    // The address of the variable is in `$t1`, and the value read from input is in `$v0`.
    printf("\tsw $v0 0($t1)\n");

    return;
}

/**
 * visitCommaOp - Traverses a tree of `CommaOp` nodes and applies a callback function to each non-CommaOp node.
 *
 * This function is designed to handle nodes structured as a `CommaOp` tree, where each `CommaOp` node
 * represents a binary operation that separates its left and right children. It recursively visits all child nodes
 * and applies the provided callback function to non-CommaOp nodes.
 *
 * @param treenode The syntax tree node to traverse.
 *                 Nodes are expected to represent either `CommaOp` or other node types.
 * @param callback A function pointer to a callback function that processes each non-CommaOp node.
 *                 The function must take a `tree` node as an argument and return `void`.
 *                 Example usage includes functions such as `cbPrint` or `cbRead`.
 *
 * Workflow:
 * 1. If the current node is null, the function immediately returns.
 * 2. If the current node is a `CommaOp`, it recursively traverses its left and right children.
 * 3. For non-CommaOp nodes, it invokes the callback function, allowing for custom processing.
 *
 * Example 1: Printing multiple variables
 * --------------------------------------
 * Input: Comma-separated list of variables in a print statement.
 *        Example: `println(x, y, z);`
 *
 * Tree structure:
 *        CommaOp
 *       /       \
 *     x       CommaOp
 *             /      \
 *           y         z
 *
 * Callback: `cbPrint`, which generates print assembly code for each variable.
 *
 * Traversal: Processes `x`, `y`, and `z` in sequence, invoking `cbPrint` for each.
 *
 * Example 2: Reading multiple variables
 * -------------------------------------
 * Input: Comma-separated list of variables in a read statement.
 *        Example: `readln(a, b);`
 *
 * Tree structure:
 *        CommaOp
 *       /       \
 *     a         b
 *
 * Callback: `cbRead`, which generates input assembly code for each variable.
 */
void visitCommaOp(tree treenode, void(callback)(tree)) {
    // Step 1: If the node is null, return immediately
    if (IsNull(treenode)) {
        return;
    }

    // Step 2: If the node is a `CommaOp`, recursively visit its children
    if (NodeOp(treenode) == CommaOp) {
        visitCommaOp(LeftChild(treenode), callback);  // Process the left child
        visitCommaOp(RightChild(treenode), callback); // Process the right child
    }
    // Step 3: If the node is not a `CommaOp`, invoke the callback function
    else {
        callback(treenode); // Process the node using the provided callback
    }
}

/**
 * visitCallOp - Generates MIPS assembly code to prepare arguments for a function call.
 *
 * @param treenode The syntax tree node representing the arguments of the function call.
 * @param proto A string representing the argument types for the function:
 *              - 'R': Reference argument (address of the variable)
 *              - Any other character (e.g., 'V'): Value argument (actual value)
 *
 * Workflow:
 * 1. Calculate the total space needed on the stack based on the number of arguments.
 * 2. Traverse the argument tree (`treenode`) in order, matching each argument with its type in `proto`.
 * 3. Depending on the argument type:
 *    - 'R': Generate code to push the reference (address) of the variable.
 *    - 'V' or others: Generate code to evaluate the expression and push the result.
 * 4. Store each argument on the stack in reverse order for compatibility with function calling conventions.
 *
 * Example:
 * Function call: `foo(a, b + c, &d)` with proto `"VVV"`
 * Argument tree:
 *          CommaOp
 *         /      \
 *      a         CommaOp
 *               /      \
 *           b + c       &d
 *
 * Output:
 * - Evaluates and pushes `a`, `b + c`, and the address of `d` onto the stack.
 * - Updates the stack pointer accordingly.
 */
void visitCallOp(tree treenode, char *proto) {
    // Step 1: If the argument tree is null, there are no arguments to process; exit the function.
    if (IsNull(treenode)) {
        return;
    }

    // Step 2: Calculate the total stack space needed to store all arguments.
    // Each argument occupies 4 bytes, and `proto` specifies the number of arguments.
    size_t len = strlen(proto);                 // Number of arguments in the prototype
    printf("\taddi $sp, $sp, -%zu\n", len * 4); // Adjust the stack pointer to allocate space for all arguments

    // Step 3: Traverse the argument tree and process each argument.
    tree p = treenode; // Pointer to the current argument node in the tree
    int i = 0;         // Index to track the current argument in `proto`

    // Loop through the argument tree until all arguments are processed
    while (!IsNull(p)) {
        // Step 4: Determine the argument type based on `proto`.
        if (proto[i] == 'R') {
            // If the argument is passed by reference, generate code to get its address.
            visitVarOp(LeftChild(p)); // Visit the variable to load its address into `$t1`
        } else {
            // If the argument is passed by value, evaluate the expression to get its value.
            visitExpr(LeftChild(p)); // Visit the expression to compute its value into `$t1`
        }

        // Step 5: Store the argument in the appropriate location on the stack.
        // Arguments are stored in reverse order (rightmost argument is stored first).
        printf("\tsw $t1, %d($sp)\n", i * 4); // Store the value of `$t1` at the correct offset

        // Move to the next argument in the tree and increment the index for `proto`.
        p = RightChild(p);
        ++i;
    }
}

/**
 * visitCall - Generates MIPS assembly code for function or method calls.
 *
 * @param treenode The syntax tree node representing the function or method call.
 *
 * This function handles system-level calls (`println`, `print`, `readln`) as well as
 * regular user-defined function and method calls. It differentiates between system calls
 * and user-defined calls and generates appropriate assembly code.
 *
 * Workflow:
 * 1. Check if the call is to a system function (e.g., `println`, `print`, `readln`).
 * 2. For system functions, delegate handling to specific helper functions (`cbPrint`, `cbRead`).
 * 3. For user-defined functions:
 *    - Handle regular calls (`ClassName.MethodName` format).
 *    - Handle calls to object methods using their associated prototype.
 *
 * Example Usage:
 * 1. System Call (`println`):
 *    ```
 *    println("Hello, world!");
 *    ```
 *    Generates:
 *    ```
 *    .data
 *    S_1: .asciiz "Hello, world!"
 *    .text
 *    la $a0, S_1
 *    li $v0, 4
 *    syscall
 *    ```
 *
 * 2. User-Defined Function Call:
 *    ```
 *    MyClass.myMethod(arg1, arg2);
 *    ```
 *    Generates:
 *    ```
 *    addi $sp, $sp, -8
 *    sw $t1, 0($sp)  # Argument 1
 *    sw $t1, 4($sp)  # Argument 2
 *    jal MyClass.myMethod
 *    addi $sp, $sp, 8
 *    ```
 */
void visitCall(tree treenode) {
    // Extract the left-hand side (function/method reference) and right-hand side (arguments).
    tree lhs = LeftChild(treenode);
    tree rhs = RightChild(treenode);

    // Step 1: Handle system-level calls (`println`, `print`, `readln`).
    if (isSystem(treenode)) {
        // Retrieve the name of the system function (e.g., `println`).
        DefGetNameAt(LeftChild(LeftChild(RightChild(lhs))));

        // Handle `println` (prints with a newline).
        if (!strcmp(name, "println")) {
            strNode = 0;                // Reset the string flag.
            visitCommaOp(rhs, cbPrint); // Process and print all arguments.

            // If no strings were printed, print a newline explicitly.
            if (!strNode) {
                printf("\tla $a0, Enter\n");
                printf("\tli $v0, 4\n");
                printf("\tsyscall\n");
            }
            return;
        }

        // Handle `print` (prints without a newline).
        if (!strcmp(name, "print")) {
            visitCommaOp(rhs, cbPrint);
            return;
        }

        // Handle `readln` (reads input from the user).
        if (!strcmp(name, "readln")) {
            visitCommaOp(rhs, cbRead);
            return;
        }
    } else {
        // Step 2: Handle user-defined function or method calls.

        // Case 1: Regular function call (no object involved).
        if (IsNull(RightChild(lhs))) {
            // Retrieve the function name and generate a fully qualified name.
            DefGetNameAt(LeftChild(lhs));
            char *namec = getname(GetAttr(current_class, NAME_ATTR)); // Get the current class name.
            char s[1024];
            sprintf(s, "%s.%s", namec, name); // Create `ClassName.MethodName`.
            char *arg = findProto(s);         // Retrieve the method's prototype (parameter types).

            // Process arguments and call the function.
            visitCallOp(rhs, arg);                             // Generate argument passing code.
            printf("\tjal %s.%s\n", namec, name);              // Jump to the function.
            printf("\taddi $sp, $sp, %zu\n", strlen(arg) * 4); // Restore the stack pointer.
        }
        // Case 2: Method call on an object.
        else {
            char *arg, *s;

            // Visit the object to retrieve its method and prototype.
            visitVarOpWithCall(lhs, &arg, &s);

            // Load the object's method address and process arguments.
            printf("\tlw $t1, 0($t1) #2\n"); // Load the method address into `$t1`.
            visitCallOp(rhs, arg);           // Generate argument passing code.

            // Save and restore the object's base address during the call.
            printf("\tmove $s1, $s0\n"); // Save current object base address.
            printf("\tmove $s0, $t1\n"); // Set the new object base address.
            printf("\tjal %s\n", s);     // Jump to the method.
            printf("\tmove $s0, $s1\n"); // Restore the previous object base address.
            free(s);                     // Free the dynamically allocated string.
        }
    }
}

/**
 * visitAssign - Generates MIPS assembly code for an assignment statement.
 *
 * @param treenode The syntax tree node representing the assignment statement.
 *
 * This function handles assignment operations by:
 * 1. Resolving the target variable's memory location (address).
 * 2. Evaluating the expression to compute the value to be assigned.
 * 3. Storing the computed value into the resolved memory location.
 *
 * Workflow:
 * - The left child of `treenode` is the target variable.
 * - The right child of `treenode` is the expression to compute the value.
 */
void visitAssign(tree treenode) {
    // Step 1: Process the left-hand side (LHS) variable
    // `RightChild(LeftChild(treenode))` points to the LHS variable.
    visitVarOp(RightChild(LeftChild(treenode))); // Load the address of the variable into `$t1`.

    // Step 2: Save the LHS variable's address onto the stack for later use.
    printf("\taddi $sp, $sp, -4\n"); // Adjust the stack pointer to create space for the address.
    printf("\tsw $t1, 0($sp)\n");    // Store the address of the LHS variable on the stack.

    // Step 3: Process the right-hand side (RHS) expression
    // `RightChild(treenode)` points to the RHS expression.
    visitExpr(RightChild(treenode)); // Evaluate the expression and store its result in `$t1`.

    // Step 4: Retrieve the saved address of the LHS variable from the stack.
    printf("\tlw $t2, 0($sp)\n");   // Load the address of the LHS variable into `$t2`.
    printf("\taddi $sp, $sp, 4\n"); // Restore the stack pointer to its previous state.

    // Step 5: Store the value of the RHS expression into the LHS variable.
    printf("\tsw $t1, 0($t2)\n"); // Store the value in `$t1` at the address in `$t2`.
}

/**
 * visitStmt - Processes and generates code for a statement node in the syntax tree.
 *
 * @param treenode The syntax tree node representing a statement.
 *
 * This function identifies the type of statement (e.g., routine call, if-else, loop, assignment, return)
 * and invokes the appropriate handler to generate assembly code.
 *
 * Workflow:
 * - Handles the first statement of the method by setting the offset attribute.
 * - Recursively processes child statements and handles their specific operations.
 */
void visitStmt(tree treenode) {
    // Step 1: Handle the first statement in a method
    if (first_statement) {
        first_statement = 1;                                  // Mark that the first statement has been handled
        SetAttr(current_method, OFFSET_ATTR, current_offset); // Save the current offset for the method
    }

    // Step 2: Return immediately if the node is null
    if (IsNull(treenode)) {
        return; // No statement to process
    }

    // Step 3: Visit the left child of the statement node (if applicable)
    ActionVisitStmtLeft;

    // Step 4: Process the specific type of statement based on the operation type
    switch (NodeOp(RightChild(treenode))) {
    case RoutineCallOp: {
        // Case 1: Routine (function/method) call
        visitCall(RightChild(treenode)); // Generate code for the method call
        break;
    }
    case IfElseOp: {
        // Case 2: If-Else statement
        int p = ++current_label;                 // Generate a new label for the end of the if-else block
        visitIfStmt(RightChild(treenode), p, p); // Generate code for the if-else statement
        printf("L_%d:\n", p);                    // Emit the label for the end of the block
        return;
    }
    case LoopOp: {
        // Case 3: Loop statement (e.g., while loop)
        int start = ++current_label; // Label for the start of the loop
        int end = ++current_label;   // Label for the end of the loop

        printf("L_%d:\n", start);                    // Emit the start label
        visitExpr(LeftChild(RightChild(treenode)));  // Evaluate the loop condition
        printf("beq $t1, $0, L_%d\n", end);          // Branch to the end if the condition is false
        visitStmt(RightChild(RightChild(treenode))); // Generate code for the loop body
        printf("j L_%d\n", start);                   // Jump back to the start to reevaluate the condition
        printf("L_%d:\n", end);                      // Emit the end label
        return;
    }
    case StmtOp: {
        // Case 4: Compound statement (a sequence of statements)
        visitStmt(RightChild(treenode)); // Recursively process the right child
        return;
    }
    case AssignOp: {
        // Case 5: Assignment statement
        visitAssign(RightChild(treenode)); // Generate code for the assignment
        return;
    }
    case ReturnOp: {
        // Case 6: Return statement
        visitExpr(LeftChild(RightChild(treenode))); // Evaluate the return expression
        printf("\tmove $v0, $t1\n");                // Move the result into the return register ($v0)
        return;
    }
    case DUMMYNode: {
        // Case 7: Dummy node (empty statement)
        return; // No action required
    }
    }
}

/**
 * visit - Recursive traversal function to generate code for the syntax tree.
 *
 * This function dispatches code generation tasks based on the operation type (`NodeOp`)
 * of the current syntax tree node. It acts as the main driver for visiting and processing
 * different types of nodes, such as class definitions, method declarations, statements, etc.
 *
 * @param treenode The current syntax tree node being visited.
 */
void visit(tree treenode) {
    // Check if the current tree node is null. If yes, return immediately.
    if (!IsNull(treenode)) {
        // Dispatch code generation based on the operation type of the current node.
        switch (NodeOp(treenode)) {
        /*** Case 1: Class Definition ***/
        case ClassDefOp:
            // Visit the class definition node and generate code for the class.
            visitClassDefOp(treenode);
            break;

        /*** Case 2: Method Definition ***/
        case MethodOp:
            // Visit the method node and generate code for the method, including
            // setting up the stack frame and processing the method body.
            visitMethodOp(treenode);
            break;

        /*** Case 3: Declaration (e.g., variable or field) ***/
        case DeclOp:
            // Visit the declaration node and generate code for initializing variables.
            visitDeclOp(treenode);
            break;

        /*** Case 4: Specification (e.g., type information) ***/
        case SpecOp:
            // Visit the specification node. This is a placeholder.
            visitSpecOp(treenode);
            break;

        /*** Case 5: Type Identification ***/
        case TypeIdOp:
            // Visit the type identifier node. This may handle type-specific attributes
            // or actions, though it may be a placeholder here.
            visitTypeIdOp(treenode);
            break;

        /*** Case 6: Routine Call ***/
        case RoutineCallOp:
            // Visit the routine call node, which generates code for function or method calls.
            visitRoutineCallOp(treenode);
            break;

        /*** Case 7: Statement ***/
        case StmtOp:
            // Visit the statement node and generate code for the statement, such as
            // handling control flow, assignments, or other statement types.
            visitStmt(treenode);
            break;

        /*** Default Case: Recursive Traversal ***/
        default:
            // For nodes that don't match any specific cases, recursively visit the left
            // and right children to process all parts of the syntax tree.
            visit((tree)LeftChild(treenode));
            visit((tree)RightChild(treenode));
            break;
        }
    }
}

/**
 * Workflow Demonstration for `codegenInit` and `codegenFinish`
 *
 * These functions coordinate the setup and termination of the program's execution.
 * Below, we explain their functionality using the example program:
 *
 * Example Program:
 * ---------------------------------------------------
 * class Program {
 *     void main() {
 *         system.println("Hello, World!");
 *     }
 * }
 * ---------------------------------------------------
 *
 * **Step 1: Initialization (`codegenInit`)**
 * - `codegenInit()` begins the `.data` and `.text` sections in the MIPS assembly.
 * - It sets up global constants (e.g., `Enter` for newlines) and directs control
 *   to the runtime entry point with a jump instruction (`j main`).
 *
 * Example Assembly Output (From `codegenInit`):
 * ---------------------------------------------------
 * .data
 * Enter: .asciiz "\n"        # Define newline character
 *
 * .text
 *     j main                 # Jump to runtime entry point
 * ---------------------------------------------------
 *
 * **Step 2: Runtime Entry Point (`main` Label in `codegenFinish`)**
 * - The `main` label is the runtime entry point, generated by `codegenFinish()`.
 * - It initializes program state, invokes `Program.main`, and ensures safe termination.
 * - The label `Program.main` refers to the user-defined `main` method.
 *
 * Example Assembly Output (From `codegenFinish`):
 * ---------------------------------------------------
 * main:
 *     # Any initialization from `initwords` (if applicable)
 *     la $s0, Program.singleton  # Load singleton instance address
 *     jal Program.main           # Jump to the user-defined `Program.main`
 *
 *     # Terminate program execution
 *     li $v0, 10
 *     syscall
 * ---------------------------------------------------
 *
 * **Step 3: Execution of User-Defined `Program.main` Method**
 * - The label `Program.main` corresponds to the actual implementation of the
 *   user-defined `main` method.
 * - Instructions for program logic (e.g., `system.println("Hello, World!")`)
 *   are emitted as assembly and executed when control transfers to `Program.main`.
 *
 * Example Assembly Output:
 * ---------------------------------------------------
 * .data
 * S_1: .asciiz "Hello, World!"  # Define string constant
 *
 * .text
 * Program.main:
 *     la $a0, S_1               # Load address of "Hello, World!"
 *     li $v0, 4                 # Set syscall code for print string
 *     syscall                   # Print the string
 *
 *     la $a0, Enter             # Load address of newline
 *     li $v0, 4                 # Set syscall code for print string
 *     syscall                   # Print the newline
 * ---------------------------------------------------
 *
 * This example demonstrates how `codegenInit` and `codegenFinish` work together:
 * 1. `codegenInit` prepares the program's runtime entry point (`main` label).
 * 2. `Program.main` contains the user-defined logic, invoked from `main`.
 * 3. `codegenFinish` ensures proper initialization and termination of the program.
 */

/**
 * codegenInit - Initializes the code generation process.
 *
 * This function sets up the initial sections of the MIPS assembly code,
 * including the data segment and the entry point for the program.
 * It also emits a jump to the `main` method, which serves as the entry point
 * for the generated program.
 */
void codegenInit() {
    // Begin the `.data` section for declaring global variables or strings.
    printf(".data\n");

    // Define a string constant `Enter` containing a newline character.
    printf("Enter: .asciiz \"\n\"\n");

    // Switch to the `.text` section for executable instructions.
    printf(".text\n");

    // Emit a jump instruction to transfer control to the `main` method.
    // This marks the starting point of the program.
    printf("\tj main\n\t");
}

/**
 * codegenFinish - Finalizes the code generation process.
 *
 * This function generates the closing instructions for the program, including:
 * - Invoking the `main` method of the program.
 * - Ending the program with a system call to terminate execution.
 *
 * The emitted code uses placeholders (`%s`) for the `main` method and any
 * initialization code.
 */
void codegenFinish() {
    // Define the `main` label as the entry point of the program.
    // This label is the target of the `j main` instruction from `codegenInit`.
    printf("main:\n");

    // Emit any initialization instructions stored in `initwords`.
    // Load the singleton instance address for the program and call `main`.
    printf("%s\tla $s0, %s.singleton\n\tjal %s.main\n", initwords, entry, entry);

    // Use a MIPS system call (code `10`) to terminate the program.
    printf("\tli $v0, 10\n\tsyscall\n");
}

int main() {
    // Step 1: Initialize the syntax tree to NULL
    SyntaxTree = NULL;

    // Step 2: Parse the source code and generate the syntax tree
    yyparse(); /* make syntax tree */

    // Step 3: Check if the syntax tree was successfully created
    if (SyntaxTree == NULL) {
        // If not, print an error message and exit the program
        fprintf(stderr, "Syntax Tree not created, exiting...\n");
        exit(1);
    }

    // Step 4: Print the symbol table and syntax tree to standard output
    FILE *outputFile = stdout;
    table = outputFile;   // Set the output for the symbol table
    treelst = outputFile; // Set the output for the syntax tree

    // Initialize the symbol table (semantic analysis phase)
    STInit();

    // Perform semantic checks and modifications on the syntax tree
    MkST(SyntaxTree);

    // Print the symbol table and syntax tree
    STPrint();                // Print the symbol table
    printtree(SyntaxTree, 0); // Print the syntax tree

    // Step 5: Redirect standard output to the generated assembly file
    freopen("code.s", "w", stdout);

    // Step 6: Begin the code generation process with initialization steps
    codegenInit();

    // Step 7: Traverse the syntax tree and generate assembly instructions
    visit(SyntaxTree);

    // Step 8: Finalize the code generation process
    codegenFinish();

    // Step 9: Close the output file
    fclose(stdout);

    // Return 0 to indicate successful execution
    return 0;
}
